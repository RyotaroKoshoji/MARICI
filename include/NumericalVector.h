#ifndef MATHTOOLKIT_LINEARALGEBRA_NUMERICALVECTOR_H
#define MATHTOOLKIT_LINEARALGEBRA_NUMERICALVECTOR_H

#include <cmath>
#include <numeric>

#include <string>
#include <algorithm>
#include <complex>
#include <valarray>

#include "ArgumentOutOfRangeException.h"

#include "FixedSizeNumericalVector.h"


namespace MathToolkit
{
	namespace LinearAlgebra
	{
		template <typename T>
		class NumericalVectorSlice;

		template <typename T, unsigned short column_size, unsigned short row_size>
		class NumericalMatrix;

		class NumericalSymmetricMatrix;


		template <typename T>
		class NumericalVector<T, 0> final
		{
			friend NumericalMatrix<T, 0, 0>;

		public:
			using size_type = std::size_t;
			using value_type = T;
			using iterator = value_type*;
			using const_iterator = const value_type*;

// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Constructors, destructor, and operators

		public:
			NumericalVector() noexcept;
			explicit NumericalVector(const size_type) noexcept;
			NumericalVector(const size_type, const value_type) noexcept;
			NumericalVector(std::initializer_list<value_type>);

			explicit NumericalVector(const NumericalVectorSlice<T>&);
			NumericalVector& operator=(const NumericalVectorSlice<T>&);
			NumericalVector& operator=(const value_type scalar) noexcept;

			NumericalVector(const NumericalVector&) = default;
			NumericalVector(NumericalVector&&) noexcept = default;
			NumericalVector& operator=(const NumericalVector&) = default;
			NumericalVector& operator=(NumericalVector&&) noexcept = default;

			template <typename U>
			explicit NumericalVector(const NumericalVector<U, 0>);

			template <typename U>
			NumericalVector& operator=(const NumericalVector<U, 0>);

			virtual ~NumericalVector() = default;

		// Constructors, destructor, and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Property

			value_type operator[](const size_type index) const noexcept;
			value_type& operator[](const size_type index) noexcept;
			value_type at(const size_type index) const;
			value_type& at(const size_type index);

			iterator begin() noexcept;
			const_iterator begin() const noexcept;
			iterator end() noexcept;
			const_iterator end() const noexcept;

		// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Unary operators

			NumericalVector& operator+=(const NumericalVector&);
			NumericalVector& operator-=(const NumericalVector&);
			NumericalVector& operator*=(const value_type scalingMultiplier) noexcept;
			NumericalVector& operator/=(const value_type scalingDivider) noexcept;

		// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Arithmetic methods

			NumericalVector& add(const value_type scalingMultiplier, const NumericalVector&);
			NumericalVector& add(const value_type scalingMultiplier, const NumericalVector&, const value_type selfScalingMultiplier);
			NumericalVector& add(const NumericalMatrix<T, 0, 0>&, const NumericalVector&);
			NumericalVector& transform(const NumericalMatrix<T, 0, 0>&);

		// Arithmetic methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Utility

			double norm() const noexcept;
			double normSquare() const noexcept;

			bool isEmpty() const noexcept;
			size_type size() const noexcept;

			void swap(NumericalVector&) noexcept;
			void resize(const size_type, const value_type value = value_type{});
			void clear() noexcept;

			void pushBack(const value_type value);
			void pushBack(const NumericalVector&);

		// Utility
// **********************************************************************************************************************************************************************************************************************************************************************************************

		private:
			std::valarray<value_type> _valueArray;
		};



		template <typename T>
		inline NumericalVector<T, 0> operator+(NumericalVector<T, 0> nva, const NumericalVector<T, 0>& nvb)
		{
			nva += nvb;
			return nva;
		}

		template <typename T>
		inline NumericalVector<T, 0> operator-(NumericalVector<T, 0> nva, const NumericalVector<T, 0>& nvb)
		{
			nva -= nvb;
			return nva;
		}

		template <typename T>
		inline NumericalVector<T, 0> operator*(const double scalingMultiplier, NumericalVector<T, 0> nv) noexcept
		{
			nv *= scalingMultiplier;
			return nv;
		}

		template <typename T>
		inline NumericalVector<T, 0> operator/(NumericalVector<T, 0> nv, const double scalingDivider) noexcept
		{
			nv /= scalingDivider;
			return nv;
		}

		template <typename T>
		inline double getInnerProduct(const NumericalVector<T, 0>& nva, const NumericalVector<T, 0>& nvb)
		{
			return std::inner_product(nva.begin(), nva.end(), nvb.begin(), 0.0);
		}
	}
}

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors and operators

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>::NumericalVector() noexcept
	: _valueArray{}
{
}

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>::NumericalVector(const size_type size) noexcept
	: _valueArray(value_type{ 0.0 }, size)
{
}

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>::NumericalVector(const size_type size, const value_type value) noexcept
	: _valueArray(value, size)
{
}

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>::NumericalVector(std::initializer_list<value_type> init)
	: _valueArray{ init }
{
}

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::operator=(const value_type scalar) noexcept
{
	_valueArray = scalar;
	return *this;
}

template <typename T>
template <typename U>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>::NumericalVector(const NumericalVector<U, 0> nv)
	: NumericalVector(nv.size())
{
	auto thisIter = std::begin(_valueArray);

	for (auto inputIter = nv.begin(); inputIter != nv.end(); ++inputIter, ++thisIter)
		*thisIter = static_cast<T>(*inputIter);
}

template <typename T>
template <typename U>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::operator=(const NumericalVector<U, 0> nv)
{
	_valueArray.resize(nv.size(), value_type{});
	{
		auto thisIter = std::begin(_valueArray);

		for (auto inputIter = nv.begin(); inputIter != nv.end(); ++inputIter, ++thisIter)
			*thisIter = static_cast<T>(*inputIter);
	}

	return *this;
}

// Constructors and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Property

template <typename T>
inline T MathToolkit::LinearAlgebra::NumericalVector<T, 0>::operator[](const size_type index) const noexcept
{
	return _valueArray[index];
}

template <typename T>
inline T& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::operator[](const size_type index) noexcept
{
	return _valueArray[index];
}

template <typename T>
inline T MathToolkit::LinearAlgebra::NumericalVector<T, 0>::at(size_type index) const
{
	if (index < _valueArray.size())
		return _valueArray[index];
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "at", "\"index\" is out of range." };
}

template <typename T>
inline T& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::at(size_type index)
{
	if (index < _valueArray.size())
		return _valueArray[index];
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "at", "\"index\" is out of range." };
}

template <typename T>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, 0>::iterator MathToolkit::LinearAlgebra::NumericalVector<T, 0>::begin() noexcept
{
	return std::begin(_valueArray);
}

template <typename T>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, 0>::const_iterator MathToolkit::LinearAlgebra::NumericalVector<T, 0>::begin() const noexcept
{
	return std::begin(_valueArray);
}

template <typename T>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, 0>::iterator MathToolkit::LinearAlgebra::NumericalVector<T, 0>::end() noexcept
{
	return std::end(_valueArray);
}

template <typename T>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, 0>::const_iterator MathToolkit::LinearAlgebra::NumericalVector<T, 0>::end() const noexcept
{
	return std::end(_valueArray);
}

// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Unary operators

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::operator+=(const NumericalVector& numericalVector)
{
	_valueArray += numericalVector._valueArray;
	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::operator-=(const NumericalVector& numericalVector)
{
	_valueArray -= numericalVector._valueArray;
	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::operator*=(const value_type scalingMultiplier) noexcept
{
	_valueArray *= scalingMultiplier;
	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::operator/=(const value_type scalingDivider) noexcept
{
	const value_type scalingMultiplier = (1.0 / scalingDivider);
	_valueArray *= scalingMultiplier;
	return *this;
}

// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Arithmetic methods

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::add(const value_type scalingMultiplier, const NumericalVector& numericalVector)
{
	auto iter = std::begin(numericalVector._valueArray);
	{
		for (auto& value : _valueArray)
		{
			value += (*iter) * scalingMultiplier;
			++iter;
		}
	}

	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0>& MathToolkit::LinearAlgebra::NumericalVector<T, 0>::add(const value_type scalingMultiplier, const NumericalVector& numericalVector, const value_type selfScalingMultiplier)
{
	auto iter = std::begin(numericalVector._valueArray);
	{
		for (auto& value : _valueArray)
		{
			value *= selfScalingMultiplier;
			value += (*iter) * scalingMultiplier;
			++iter;
		}
	}

	return *this;
}

// Arithmetic methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Utility

template <typename T>
inline double MathToolkit::LinearAlgebra::NumericalVector<T, 0>::norm() const noexcept
{
	return std::sqrt(normSquare());
}

template <>
inline double MathToolkit::LinearAlgebra::NumericalVector<double, 0>::normSquare() const noexcept
{
	double result{ 0.0 };
	{
		for (const auto& value : _valueArray)
			result += (value * value);
	}

	return result;
}


template <>
inline double MathToolkit::LinearAlgebra::NumericalVector<std::complex<double>, 0>::normSquare() const noexcept
{
	double result{ 0.0 };
	{
		for (const auto& value : _valueArray)
		{
			result += (value.real() * value.real());
			result += (value.imag() * value.imag());
		}
	}

	return result;
}

template <typename T>
inline bool MathToolkit::LinearAlgebra::NumericalVector<T, 0>::isEmpty() const noexcept
{
	return !(static_cast<bool>(_valueArray.size()));
}

template <typename T>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, 0>::size_type MathToolkit::LinearAlgebra::NumericalVector<T, 0>::size() const noexcept
{
	return _valueArray.size();
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVector<T, 0>::swap(NumericalVector& nv) noexcept
{
	_valueArray.swap(nv._valueArray);
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVector<T, 0>::resize(const size_type size, const value_type value)
{
	_valueArray.resize(size, value);
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVector<T, 0>::clear() noexcept
{
	std::valarray<value_type> va;
	_valueArray.swap(va);
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVector<T, 0>::pushBack(const value_type value)
{
	std::valarray<value_type> newValueArray(_valueArray.size() + 1);
	{
		std::copy(std::begin(_valueArray), std::end(_valueArray), std::begin(newValueArray));
		newValueArray[_valueArray.size()] = value;
	}

	_valueArray.swap(newValueArray);
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVector<T, 0>::pushBack(const NumericalVector& nv)
{
	std::valarray<value_type> newValueArray(_valueArray.size() + nv.size());
	{
		std::copy(std::begin(_valueArray), std::end(_valueArray), std::begin(newValueArray));
		std::copy(nv.begin(), nv.end(), (std::begin(newValueArray) + _valueArray.size()));
	}

	_valueArray.swap(newValueArray);
}

// Utility
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************


#endif // !MATHTOOLKIT_LINEARALGEBRA_NUMERICALVECTOR_H
