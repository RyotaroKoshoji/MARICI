#ifndef MATHTOOLKIT_LINEARALGEBRA_NUMERICALVECTORSLICE_H
#define MATHTOOLKIT_LINEARALGEBRA_NUMERICALVECTORSLICE_H

#include "ArgumentOutOfRangeException.h"

#include "NumericalVector.h"


namespace MathToolkit
{
	namespace LinearAlgebra
	{
		template <typename T>
		class NumericalVectorSlice final
		{
			friend MathToolkit::LinearAlgebra::NumericalMatrix<T, 0, 0>;
			friend MathToolkit::LinearAlgebra::NumericalSymmetricMatrix;

		public:
			using size_type = std::size_t;
			using value_type = T;
			using pointer = value_type*;
			using const_pointer = const value_type*;

// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Constructors, destructor, and operators

		private:
			NumericalVectorSlice(std::valarray<value_type>&, const std::slice&);

		public:
			NumericalVectorSlice(const NumericalVectorSlice&) = default;
			NumericalVectorSlice(NumericalVectorSlice&&) noexcept = default;
			~NumericalVectorSlice() = default;

			const NumericalVectorSlice& operator=(const NumericalVectorSlice&);
			void operator=(const NumericalVector<value_type, 0>&);
			void operator=(const value_type scalar);

		// Constructors, destructor, and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Arithmetic methods

			void add(const value_type scalingMultiplier, const NumericalVector<value_type, 0>&);
			void add(const value_type scalingMultiplier, const NumericalVectorSlice&);
			void add(const value_type scalingMultiplier, const NumericalVector<value_type, 0>&, const value_type selfScalingMultiplier);
			void add(const value_type scalingMultiplier, const NumericalVectorSlice&, const value_type selfScalingMultiplier);

		// Arithmetic methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Unary operators

			void operator+=(const NumericalVector<value_type, 0>&);
			void operator+=(const NumericalVectorSlice&);
			void operator-=(const NumericalVector<value_type, 0>&);
			void operator-=(const NumericalVectorSlice&);
			void operator*=(const value_type scalingMultiplier);
			void operator/=(const value_type scalingDivider);

		// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Access methods

			value_type operator[](const size_type index) const noexcept;
			value_type& operator[](const size_type index) noexcept;
			value_type at(const size_type index) const;
			value_type& at(const size_type index);

			size_type start() const noexcept;
			size_type size() const noexcept;
			size_type stride() const noexcept;

			double norm() const noexcept;
			double normSquare() const noexcept;

		// Access methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Friends and private methods

		private:
			pointer begin() noexcept;
			const_pointer begin() const noexcept;

		// Friends and private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************

		private:
			std::valarray<value_type>& _valueArraySlice;
			size_type _start;
			size_type _size;
			size_type _stride;

		private:
			NumericalVectorSlice() = delete;
			NumericalVectorSlice& operator=(NumericalVectorSlice&&) = delete;
		};
	}
}

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Arithmetic methods

template <typename T>
inline const MathToolkit::LinearAlgebra::NumericalVectorSlice<T>& MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator=(const NumericalVectorSlice& numericalVectorSlice)
{
	if (_size == numericalVectorSlice._size)
	{
		auto thisIter = begin();
		auto iter = numericalVectorSlice.begin();

		for (size_type index = 0; index < _size; ++index)
		{
			*thisIter = (*iter);

			thisIter += _stride;
			iter += numericalVectorSlice._stride;
		}

		return *this;
	}

	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "operator=", "The size of \"numericalVectorSlice\" is not equal to the size of this." };
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator=(const NumericalVector<value_type, 0>& numericalVector)
{
	if (_size == numericalVector.size())
	{
		auto thisIter = begin();
		auto iter = numericalVector.begin();

		for (size_type index = 0; index < _size; ++index)
		{
			*thisIter = (*iter);

			thisIter += _stride;
			++iter;
		}
	}

	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "operator=", "The size of \"numericalVectorBase\" is not equal to the size of this." };
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator=(const value_type scalar)
{
	auto thisIter = begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) = scalar;
		thisIter += _stride;
	}
}


// Arithmetic methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Arithmetic methods

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::add(const value_type scalingMultiplier, const NumericalVector<value_type, 0>& numericalVectorBase)
{
	auto thisIter = begin();
	auto iter = numericalVectorBase.begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) += (*iter) * scalingMultiplier;

		thisIter += _stride;
		++iter;
	}
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::add(const value_type scalingMultiplier, const NumericalVectorSlice& numericalVectorSlice)
{
	auto thisIter = begin();
	auto iter = numericalVectorSlice.begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) += (*iter) * scalingMultiplier;

		thisIter += _stride;
		iter += numericalVectorSlice._stride;
	}
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::add(const value_type scalingMultiplier, const NumericalVector<value_type, 0>& numericalVector, const value_type selfScalingMultiplier)
{
	auto thisIter = begin();
	auto iter = numericalVector.begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) *= selfScalingMultiplier;
		(*thisIter) += (*iter) * scalingMultiplier;

		thisIter += _stride;
		++iter;
	}
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::add(const value_type scalingMultiplier, const NumericalVectorSlice& numericalVectorSlice, const value_type selfScalingMultiplier)
{
	auto thisIter = begin();
	auto iter = numericalVectorSlice.begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) *= selfScalingMultiplier;
		(*thisIter) += (*iter) * scalingMultiplier;

		thisIter += _stride;
		iter += numericalVectorSlice._stride;
	}
}

// Arithmetic methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Unary operators

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator+=(const NumericalVector<value_type, 0>& numericalVector)
{
	auto thisIter = begin();
	auto iter = numericalVector.begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) += (*iter);

		thisIter += _stride;
		++iter;
	}
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator+=(const NumericalVectorSlice& numericalVectorSlice)
{
	auto thisIter = begin();
	auto iter = numericalVectorSlice.begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) += (*iter);

		thisIter += _stride;
		iter += numericalVectorSlice._stride;
	}
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator-=(const NumericalVector<value_type, 0>& numericalVector)
{
	auto thisIter = begin();
	auto iter = numericalVector.begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) -= (*iter);

		thisIter += _stride;
		++iter;
	}
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator-=(const NumericalVectorSlice& numericalVectorSlice)
{
	auto thisIter = begin();
	auto iter = numericalVectorSlice.begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) -= (*iter);

		thisIter += _stride;
		iter += numericalVectorSlice._stride;
	}
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator*=(const value_type scalingMultiplier)
{
	auto thisIter = begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) *= scalingMultiplier;
		thisIter += _stride;
	}
}

template <typename T>
inline void MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator/=(const value_type scalingDivider)
{
	const value_type scalingMultiplier = (1.0 / scalingDivider);
	auto thisIter = begin();

	for (size_type index = 0; index < _size; ++index)
	{
		(*thisIter) *= scalingMultiplier;
		thisIter += _stride;
	}
}

// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Access methods

template <typename T>
inline T MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator[](const size_type index) const noexcept
{
	return _valueArraySlice[_start + (_stride * index)];
}

template <typename T>
inline T& MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::operator[](const size_type index) noexcept
{
	return _valueArraySlice[_start + (_stride * index)];
}

template <typename T>
inline T MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::at(const size_type index) const
{
	if (index < _size)
		return _valueArraySlice[_start + (_stride * index)];
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "at", "Index is out of range." };
}

template <typename T>
inline T& MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::at(const size_type index)
{
	if (index < _size)
		return _valueArraySlice[_start + (_stride * index)];
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "at", "Index is out of range." };
}

template <typename T>
inline typename MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::size_type MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::start() const noexcept
{
	return _start;
}

template <typename T>
inline typename MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::size_type MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::size() const noexcept
{
	return _size;
}

template <typename T>
inline typename MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::size_type MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::stride() const noexcept
{
	return _stride;
}

template <typename T>
inline double MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::norm() const noexcept
{
	return std::sqrt(normSquare());
}

template <>
inline double MathToolkit::LinearAlgebra::NumericalVectorSlice<double>::normSquare() const noexcept
{
	double result{ 0.0 };
	{
		auto thisIter = begin();

		for (size_type index = 0; index < _size; ++index)
		{
			result += (*thisIter) * (*thisIter);
			thisIter += _stride;
		}
	}

	return result;
}

template <>
inline double MathToolkit::LinearAlgebra::NumericalVectorSlice<std::complex<double>>::normSquare() const noexcept
{
	double result{ 0.0 };
	{
		auto thisIter = begin();

		for (size_type index = 0; index < _size; ++index)
		{
			result += (thisIter->real()) * (thisIter->real());
			result += (thisIter->imag()) * (thisIter->imag());
			thisIter += _stride;
		}
	}

	return result;
}


// Access methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private methods

template <typename T>
inline T* MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::begin() noexcept
{
	return (std::begin(_valueArraySlice) + _start);
}

template <typename T>
inline const T* MathToolkit::LinearAlgebra::NumericalVectorSlice<T>::begin() const noexcept
{
	return (std::begin(_valueArraySlice) + _start);
}

// Private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************

#endif // !MATHTOOLKIT_LINEARALGEBRA_INTERNAL_NUMERICALVECTORSLICE_H
