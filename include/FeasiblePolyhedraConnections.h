#ifndef MATHEMATICALCRYSTALCHEMISTRY_CRYSTALMODEL_CONSTRAINTS_FEASIBLEPOLYHEDRACONNECTIONS_H
#define MATHEMATICALCRYSTALCHEMISTRY_CRYSTALMODEL_CONSTRAINTS_FEASIBLEPOLYHEDRACONNECTIONS_H

#include <unordered_map>
#include <utility>

#include "AtomicNumber.h"
#include "ChemicalComposition.h"

#include "IonicAtomicNumber.h"


namespace MathematicalCrystalChemistry
{
	namespace CrystalModel
	{
		namespace Constraints
		{
			class FeasiblePolyhedraConnections
			{
				using size_type = unsigned short;
				using AtomicNumber = ChemToolkit::Generic::AtomicNumber;
				using IonicAtomicNumber = ChemToolkit::Generic::IonicAtomicNumber;
				using ChemicalComposition = ChemToolkit::Generic::ChemicalComposition<AtomicNumber>;


				struct KeyHasher
				{
					std::size_t operator()(const std::pair<IonicAtomicNumber, IonicAtomicNumber>&) const noexcept;
				};

				struct KeyEqual
				{
					bool operator()(const std::pair<IonicAtomicNumber, IonicAtomicNumber>&, const std::pair<IonicAtomicNumber, IonicAtomicNumber>&) const noexcept;
				};

// **********************************************************************************************************************************************************************************************************************************************************************************************
			// Constructors, destructor, and operators

			public:
				FeasiblePolyhedraConnections() noexcept;
				virtual ~FeasiblePolyhedraConnections() = default;

				FeasiblePolyhedraConnections(const FeasiblePolyhedraConnections&) = default;
				FeasiblePolyhedraConnections(FeasiblePolyhedraConnections&&) noexcept = default;
				FeasiblePolyhedraConnections& operator=(const FeasiblePolyhedraConnections&) = default;
				FeasiblePolyhedraConnections& operator=(FeasiblePolyhedraConnections&&) noexcept = default;

			// Constructors, destructor, and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
			// Methods

				bool isFeasibleCommonBridgingComposition(const IonicAtomicNumber&, const IonicAtomicNumber&, const ChemicalComposition&) const;
				ChemicalComposition getClosestFeasibleCommonBridgingComposition(const IonicAtomicNumber&, const IonicAtomicNumber&, const ChemicalComposition&) const;

			// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
			// Private methods

			private:
				std::pair<IonicAtomicNumber, IonicAtomicNumber> getIonicAtomicNumberKey(const IonicAtomicNumber&, const IonicAtomicNumber&) const;

			// Private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************

			private:
				std::unordered_map<std::pair<IonicAtomicNumber, IonicAtomicNumber>, std::vector<ChemicalComposition>, KeyHasher, KeyEqual> _dictionary;
			};



			inline std::size_t FeasiblePolyhedraConnections::KeyHasher::operator()(const std::pair<IonicAtomicNumber, IonicAtomicNumber>& ianp) const noexcept
			{
				return (ianp.first.getHashCode() ^ ianp.second.getHashCode());
			}

			inline bool FeasiblePolyhedraConnections::KeyEqual::operator()(const std::pair<IonicAtomicNumber, IonicAtomicNumber>& ianpa, const std::pair<IonicAtomicNumber, IonicAtomicNumber>& ianpb) const noexcept
			{
				return (ianpa == ianpb);
			}
		}
	}
}

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Methods

inline bool MathematicalCrystalChemistry::CrystalModel::Constraints::FeasiblePolyhedraConnections::isFeasibleCommonBridgingComposition(const IonicAtomicNumber& iana, const IonicAtomicNumber& ianb, const ChemicalComposition& commonBridgingComposition) const
{
	auto iter = _dictionary.find(getIonicAtomicNumberKey(iana, ianb));

	if (iter == _dictionary.end())
		return true;
	else
	{
		if (iter->second.empty())
			return true;

		else
		{
			for (const auto& feasibleComposition : iter->second)
			{
				if (feasibleComposition == commonBridgingComposition)
					return true;
			}

			return false;
		}
	}
}

// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private methods

inline std::pair<MathematicalCrystalChemistry::CrystalModel::Constraints::FeasiblePolyhedraConnections::IonicAtomicNumber, MathematicalCrystalChemistry::CrystalModel::Constraints::FeasiblePolyhedraConnections::IonicAtomicNumber> MathematicalCrystalChemistry::CrystalModel::Constraints::FeasiblePolyhedraConnections::getIonicAtomicNumberKey(const IonicAtomicNumber& iana, const IonicAtomicNumber& ianb) const
{
	if (ianb < iana)
		return std::make_pair(ianb, iana);
	else
		return std::make_pair(iana, ianb);
}

// Private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************


#endif // !MATHEMATICALCRYSTALCHEMISTRY_CRYSTALMODEL_CONSTRAINTS_FEASIBLEPOLYHEDRACONNECTIONS_H
