#ifndef CHEMTOOLKIT_CRYSTALLOGRAPHY_CRYSTALSTRUCTURE_H
#define CHEMTOOLKIT_CRYSTALLOGRAPHY_CRYSTALSTRUCTURE_H

#include <cmath>
#include <vector>

#include "NumericalVector.h"
#include "NumericalMatrix.h"

#include "AtomIndex.h"
#include "UnitCell.h"


namespace ChemToolkit
{
	namespace Crystallography
	{
		template <typename A>
		class CrystalStructure
		{
			using Atom = A;

		protected:
			using size_type = unsigned short;
			using NumericalVector = MathToolkit::LinearAlgebra::NumericalVector<double, 3>;
			using NumericalMatrix = MathToolkit::LinearAlgebra::NumericalMatrix<double, 3, 3>;

			using OriginalAtomIndex = ChemToolkit::Crystallography::OriginalAtomIndex;
			using TranslatedAtomIndex = ChemToolkit::Crystallography::TranslatedAtomIndex;
			using LatticePoint = TranslatedAtomIndex::LatticePoint;

// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Constructors, destructor, and operators

		public:
			CrystalStructure() noexcept;
			explicit CrystalStructure(const UnitCell&) noexcept;
			CrystalStructure(const UnitCell&, const std::vector<Atom>&) noexcept;
			CrystalStructure(const UnitCell&, std::vector<Atom>&&) noexcept;

			virtual ~CrystalStructure() = default;

			CrystalStructure(const CrystalStructure&) = default;
			CrystalStructure(CrystalStructure&&) noexcept = default;
			CrystalStructure& operator=(const CrystalStructure&) = default;
			CrystalStructure& operator=(CrystalStructure&&) noexcept = default;

		// Constructors, destructor, and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Property

			const UnitCell& unitCell() const noexcept;
			UnitCell& unitCell() noexcept;

			const std::vector<Atom>& atoms() const noexcept;
			std::vector<Atom>& atoms() noexcept;

		// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Methods

			virtual void initialize() noexcept;
			virtual void initialize(const UnitCell&) noexcept;
			virtual void initialize(const UnitCell&, const std::vector<Atom>&) noexcept;
			virtual void initialize(const UnitCell&, std::vector<Atom>&&) noexcept;

			virtual void normalizeAverageFractionalCoordinates();
			virtual void normalizeFractionalCoordinates();

			template <typename B>
			void setAtomicCoordinates(const std::vector<B>&) noexcept;

			bool isValid() const noexcept;

		// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Protected methods

		protected:
			bool isOriginalLatticePoint(const LatticePoint& latticePoint) const noexcept;

			NumericalVector toTranslationVector(const LatticePoint& latticePoint) const noexcept;

		// Protected methods
// **********************************************************************************************************************************************************************************************************************************************************************************************

		private:
			UnitCell _unitCell;
			std::vector<Atom> _atoms;
		};
	}
}

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors

template <typename A>
inline ChemToolkit::Crystallography::CrystalStructure<A>::CrystalStructure() noexcept
	: _unitCell{}
	, _atoms{}
{
}

template <typename A>
inline ChemToolkit::Crystallography::CrystalStructure<A>::CrystalStructure(const UnitCell& cell) noexcept
	: _unitCell{ cell.basisVectors() }
	, _atoms{}
{
}

template <typename A>
inline ChemToolkit::Crystallography::CrystalStructure<A>::CrystalStructure(const UnitCell& cell, const std::vector<Atom>& atomicArrangement) noexcept
	: _unitCell{ cell }
	, _atoms{ atomicArrangement }
{
}

template <typename A>
inline ChemToolkit::Crystallography::CrystalStructure<A>::CrystalStructure(const UnitCell& cell, std::vector<Atom>&& atomicArrangement) noexcept
	: _unitCell{ cell }
	, _atoms{ std::move(atomicArrangement) }
{
}

// Constructors
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Properties

template <typename A>
inline const ChemToolkit::Crystallography::UnitCell& ChemToolkit::Crystallography::CrystalStructure<A>::unitCell() const noexcept
{
	return _unitCell;
}

template <typename A>
inline ChemToolkit::Crystallography::UnitCell& ChemToolkit::Crystallography::CrystalStructure<A>::unitCell() noexcept
{
	return _unitCell;
}

template <typename A>
inline const std::vector<A>& ChemToolkit::Crystallography::CrystalStructure<A>::atoms() const noexcept
{
	return _atoms;
}

template <typename A>
inline std::vector<A>& ChemToolkit::Crystallography::CrystalStructure<A>::atoms() noexcept
{
	return _atoms;
}

// Properties
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Methods

template <typename A>
inline void ChemToolkit::Crystallography::CrystalStructure<A>::initialize() noexcept
{
	_unitCell.clear();
	_atoms.clear();
}

template <typename A>
inline void ChemToolkit::Crystallography::CrystalStructure<A>::initialize(const UnitCell& uc) noexcept
{
	_unitCell.basisVectors() = uc.basisVectors();
	_atoms.clear();
}

template <typename A>
inline void ChemToolkit::Crystallography::CrystalStructure<A>::initialize(const UnitCell& uc, const std::vector<Atom>& atomicArrangement) noexcept
{
	_unitCell = uc;
	_atoms = atomicArrangement;
}

template <typename A>
inline void ChemToolkit::Crystallography::CrystalStructure<A>::initialize(const UnitCell& uc, std::vector<Atom>&& atomicArrangement) noexcept
{
	_unitCell = uc;
	_atoms = std::move(atomicArrangement);
}

template <typename A>
inline void ChemToolkit::Crystallography::CrystalStructure<A>::normalizeAverageFractionalCoordinates()
{
	NumericalMatrix inverseBasisVectors = _unitCell.getInverseBasisVectors();
	NumericalVector averageLatticePoint;
	{
		for (const auto& atom : _atoms)
		{
			NumericalVector fractionalCoordinate = inverseBasisVectors * atom.cartesianCoordinate();
			averageLatticePoint[0] += std::floor(fractionalCoordinate[0]);
			averageLatticePoint[1] += std::floor(fractionalCoordinate[1]);
			averageLatticePoint[2] += std::floor(fractionalCoordinate[2]);
		}


		averageLatticePoint /= static_cast<double>(_atoms.size());
		averageLatticePoint[0] = std::floor(averageLatticePoint[0]);
		averageLatticePoint[1] = std::floor(averageLatticePoint[1]);
		averageLatticePoint[2] = std::floor(averageLatticePoint[2]);
	}


	for (auto& atom : _atoms)
	{
		NumericalVector fractionalCoordinate = inverseBasisVectors * atom.cartesianCoordinate();
		fractionalCoordinate -= averageLatticePoint;

		atom.cartesianCoordinate() = (_unitCell.basisVectors() * fractionalCoordinate);
	}
}

template <typename A>
inline void ChemToolkit::Crystallography::CrystalStructure<A>::normalizeFractionalCoordinates()
{
	NumericalMatrix inverseBasisVectors = _unitCell.getInverseBasisVectors();

	for (auto& atom : _atoms)
	{
		NumericalVector fractionalCoordinate = inverseBasisVectors * atom.cartesianCoordinate();
		int floorValueA = static_cast<int>(std::floor(fractionalCoordinate[0]));
		int floorValueB = static_cast<int>(std::floor(fractionalCoordinate[1]));
		int floorValueC = static_cast<int>(std::floor(fractionalCoordinate[2]));

		if (floorValueA != 0)
			fractionalCoordinate[0] -= static_cast<double>(floorValueA);
		if (floorValueB != 0)
			fractionalCoordinate[1] -= static_cast<double>(floorValueB);
		if (floorValueC != 0)
			fractionalCoordinate[2] -= static_cast<double>(floorValueC);


		atom.cartesianCoordinate() = (_unitCell.basisVectors() * fractionalCoordinate);
	}
}

template <typename A>
template <typename B>
inline void ChemToolkit::Crystallography::CrystalStructure<A>::setAtomicCoordinates(const std::vector<B>& atomicArrangement) noexcept
{
	_atoms.clear();

	for (const auto& atom : atomicArrangement)
		_atoms.push_back(Atom{ atom.elementSymbol(), atom.cartesianCoordinate() });
}

template <typename A>
inline bool ChemToolkit::Crystallography::CrystalStructure<A>::isValid() const noexcept
{
	if (_atoms.empty())
		return false;

	for (const auto& atom : _atoms)
	{
		if (!(atom.isValid()))
			return false;
	}

	return true;
}

// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Protected methods

template <typename A>
inline bool ChemToolkit::Crystallography::CrystalStructure<A>::isOriginalLatticePoint(const LatticePoint& latticePoint) const noexcept
{
	if ((latticePoint[0] == 0) && (latticePoint[1] == 0) && (latticePoint[2] == 0))
		return true;
	else
		return false;
}


template <typename A>
inline typename ChemToolkit::Crystallography::CrystalStructure<A>::NumericalVector ChemToolkit::Crystallography::CrystalStructure<A>::toTranslationVector(const LatticePoint& latticePoint) const noexcept
{
	NumericalMatrix::const_iterator iter = _unitCell.basisVectors().begin();
	double latticePointA = static_cast<double>(latticePoint[0]);
	double latticePointB = static_cast<double>(latticePoint[1]);
	double latticePointC = static_cast<double>(latticePoint[2]);

	NumericalVector translationVector;
	{
		translationVector[0] += (*iter) * latticePointA;
		++iter;
		translationVector[1] += (*iter) * latticePointA;
		++iter;
		translationVector[2] += (*iter) * latticePointA;
		++iter;

		translationVector[0] += (*iter) * latticePointB;
		++iter;
		translationVector[1] += (*iter) * latticePointB;
		++iter;
		translationVector[2] += (*iter) * latticePointB;
		++iter;

		translationVector[0] += (*iter) * latticePointC;
		++iter;
		translationVector[1] += (*iter) * latticePointC;
		++iter;
		translationVector[2] += (*iter) * latticePointC;
	}

	return translationVector;
}

// Protected methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************


#endif // !CHEMTOOLKIT_CRYSTALLOGRAPHY_CRYSTALSTRUCTURE_H
