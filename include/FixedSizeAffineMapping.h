#ifndef MATHTOOLKIT_LINEARALGEBRA_FIXEDSIZEAFFINEMAPPING_H
#define MATHTOOLKIT_LINEARALGEBRA_FIXEDSIZEAFFINEMAPPING_H

#include "ArgumentOutOfRangeException.h"

#include "NumericalMatrix.h"
#include "NumericalVector.h"


namespace MathToolkit
{
	namespace LinearAlgebra
	{
		template <typename T, unsigned short column_size, unsigned short row_size>
		class AffineMapping
		{
		protected:
			using size_type = std::size_t;
			using value_type = T;

// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Constructors, destructor, and operators

		public:
			AffineMapping() noexcept;
			explicit AffineMapping(const NumericalMatrix<value_type, column_size, row_size>&) noexcept;
			explicit AffineMapping(NumericalMatrix<value_type, column_size, row_size>&&) noexcept;
			AffineMapping(const NumericalMatrix<value_type, column_size, row_size>&, const NumericalVector<value_type, column_size>&) noexcept;
			AffineMapping(NumericalMatrix<value_type, column_size, row_size>&&, NumericalVector<value_type, column_size>&&) noexcept;

			AffineMapping(const AffineMapping&) = default;
			AffineMapping(AffineMapping&&) noexcept = default;
			AffineMapping& operator=(const AffineMapping&) = default;
			AffineMapping& operator=(AffineMapping&&) noexcept = default;

			virtual ~AffineMapping() = default;

		// Constructors, destructor, and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Property

			const NumericalMatrix<value_type, column_size, row_size>& matrixPart() const noexcept;
			const NumericalVector<value_type, column_size>& columnPart() const noexcept;

			void setMatrixPart(const NumericalMatrix<value_type, column_size, row_size>&);
			void setMatrixPart(NumericalMatrix<value_type, column_size, row_size>&&);
			void setColumnPart(const NumericalVector<value_type, column_size>&);
			void setColumnPart(NumericalVector<value_type, column_size>&&);

		// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Operators

			NumericalVector<value_type, column_size> operator()(const NumericalVector<value_type, column_size>&) const noexcept;

			AffineMapping& operator*=(const NumericalMatrix<value_type, column_size, row_size>&) noexcept;
			AffineMapping& operator*=(const AffineMapping&) noexcept;

		// Operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Mathematical methods

			AffineMapping& transform(const NumericalMatrix<value_type, column_size, row_size>&) noexcept;
			AffineMapping& transform(const AffineMapping&) noexcept;
			AffineMapping& transform(const value_type scalingMultiplier, const NumericalMatrix<value_type, column_size, row_size>&) noexcept;
			AffineMapping& transform(const value_type scalingMultiplier, const AffineMapping&) noexcept;
			AffineMapping& multiply(const value_type scalingMultiplier, const NumericalMatrix<value_type, column_size, row_size>&) noexcept;
			AffineMapping& multiply(const value_type scalingMultiplier, const AffineMapping&) noexcept;

		// Mathematical methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Methods

			bool isAvailable() const noexcept;

		// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
	
		private:
			NumericalMatrix<value_type, column_size, row_size> _matrixPart;
			NumericalVector<value_type, column_size> _columnPart;
		};
	}
}

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::AffineMapping() noexcept
	: _matrixPart{}
	, _columnPart{}
{
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::AffineMapping(const NumericalMatrix<T, column_size, row_size>& matrixPart) noexcept
	: _matrixPart{ matrixPart }
	, _columnPart{}
{
	_columnPart = NumericalVector<T, column_size>(_matrixPart.columnSize());
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::AffineMapping(NumericalMatrix<T, column_size, row_size>&& matrixPart) noexcept
	: _matrixPart{ std::move(matrixPart) }
	, _columnPart{}
{
	_columnPart = NumericalVector<T, column_size>(_matrixPart.columnSize());
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::AffineMapping(const NumericalMatrix<T, column_size, row_size>& matrixPart, const NumericalVector<T, column_size>& columnPart) noexcept
	: _matrixPart{ matrixPart }
	, _columnPart{ columnPart }
{
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::AffineMapping(NumericalMatrix<T, column_size, row_size>&& matrixPart, NumericalVector<T, column_size>&& columnPart) noexcept
	: _matrixPart{ std::move(matrixPart) }
	, _columnPart{ std::move(columnPart) }
{
}

// Constructors
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Property

template <typename T, unsigned short column_size, unsigned short row_size>
inline const MathToolkit::LinearAlgebra::NumericalMatrix<T, column_size, row_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::matrixPart() const noexcept
{
	return _matrixPart;
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline const MathToolkit::LinearAlgebra::NumericalVector<T, column_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::columnPart() const noexcept
{
	return _columnPart;
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline void MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::setMatrixPart(const NumericalMatrix<T, column_size, row_size>& matrixPart)
{
	if ((_matrixPart.columnSize() == matrixPart.columnSize()) && (_matrixPart.rowSize() == matrixPart.rowSize()))
		_matrixPart = matrixPart;
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "setMatrixPart", "The column and/or row sizes are not the same as the old values." };
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline void MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::setMatrixPart(NumericalMatrix<T, column_size, row_size>&& matrixPart)
{
	if ((_matrixPart.columnSize() == matrixPart.columnSize()) && (_matrixPart.rowSize() == matrixPart.rowSize()))
		_matrixPart = std::move(matrixPart);
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "setMatrixPart", "The column and/or row sizes are not the same as the old values." };
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline void MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::setColumnPart(const NumericalVector<T, column_size>& columnPart)
{
	if (_columnPart.size() == columnPart.size())
		_columnPart = columnPart;
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "setColumnPart", "Size is not the same as the old value." };
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline void MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::setColumnPart(NumericalVector<T, column_size>&& columnPart)
{
	if (_columnPart.size() == columnPart.size())
		_columnPart = std::move(columnPart);
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "setColumnPart", "Size is not the same as the old value." };
}

// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Unary operators

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::NumericalVector<T, column_size> MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::operator()(const NumericalVector<T, column_size>& nv) const noexcept
{
	NumericalVector<T, column_size> newNumericalVector = _matrixPart * nv;
	newNumericalVector += _columnPart;

	return newNumericalVector;
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::operator*=(const NumericalMatrix<value_type, column_size, row_size>& nm) noexcept
{
	_matrixPart *= nm;
	return *this;
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::operator*=(const AffineMapping& am) noexcept
{
	_matrixPart *= am._matrixPart;
	_columnPart += _matrixPart * am._columnPart;

	return *this;
}

// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Mathematical methods

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::transform(const NumericalMatrix<value_type, column_size, row_size>& nm) noexcept
{
	_matrixPart.transform(nm);
	_columnPart.transform(nm);
	return *this;
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::transform(const AffineMapping& am) noexcept
{
	_matrixPart.transform(am._matrixPart);
	_columnPart.swap(am._matrixPart * _columnPart);
	_columnPart += am._columnPart;
	return *this;
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::transform(const value_type scalingMultiplier, const NumericalMatrix<value_type, column_size, row_size>& nm) noexcept
{
	_matrixPart.transform(scalingMultiplier, nm);
	_columnPart.swap(nm * _columnPart);
	_columnPart *= scalingMultiplier;
	return *this;
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::transform(const value_type scalingMultiplier, const AffineMapping& am) noexcept
{
	_matrixPart.transform(scalingMultiplier, am._matrixPart);
	_columnPart.swap(am._matrixPart * _columnPart);
	_columnPart += am._columnPart;
	_columnPart *= scalingMultiplier;
	return *this;
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::multiply(const value_type scalingMultiplier, const NumericalMatrix<value_type, column_size, row_size>& nm) noexcept
{
	_matrixPart.multiply(scalingMultiplier, nm.matrixPart());
	return *this;
}

template <typename T, unsigned short column_size, unsigned short row_size>
inline MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>& MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::multiply(const value_type scalingMultiplier, const AffineMapping& am) noexcept
{
	_matrixPart.multiply(scalingMultiplier, am._matrixPart);
	_columnPart += scalingMultiplier * (_matrixPart * am._columnPart);
	return *this;
}

// Mathematical methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Methods

template <typename T, unsigned short column_size, unsigned short row_size>
inline bool MathToolkit::LinearAlgebra::AffineMapping<T, column_size, row_size>::isAvailable() const noexcept
{
	return !(_matrixPart.isEmpty());
}

// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************


#endif // !MATHTOOLKIT_LINEARALGEBRA_FIXEDSIZEAFFINEMAPPING_H
