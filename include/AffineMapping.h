#ifndef MATHTOOLKIT_LINEARALGEBRA_AFFINEMAPPING_H
#define MATHTOOLKIT_LINEARALGEBRA_AFFINEMAPPING_H

#include "ArgumentOutOfRangeException.h"

#include "FixedSizeAffineMapping.h"


namespace MathToolkit
{
	namespace LinearAlgebra
	{
		template <typename T>
		class AffineMapping<T, 0, 0>
		{
		protected:
			using size_type = std::size_t;
			using value_type = T;

// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Constructors, destructor, and operators

		public:
			AffineMapping() noexcept;
			explicit AffineMapping(const NumericalMatrix<value_type, 0, 0>&);
			explicit AffineMapping(NumericalMatrix<value_type, 0, 0>&&);
			AffineMapping(const NumericalMatrix<value_type, 0, 0>&, const NumericalVector<value_type, 0>&);
			AffineMapping(NumericalMatrix<value_type, 0, 0>&&, NumericalVector<value_type, 0>&&);

			AffineMapping(const AffineMapping&) = default;
			AffineMapping(AffineMapping&&) noexcept = default;
			AffineMapping& operator=(const AffineMapping&) = default;
			AffineMapping& operator=(AffineMapping&&) noexcept = default;

			virtual ~AffineMapping() = default;

		// Constructors, destructor, and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Property

			const NumericalMatrix<value_type, 0, 0>& matrixPart() const noexcept;
			const NumericalVector<value_type, 0>& columnPart() const noexcept;

			void setMatrixPart(const NumericalMatrix<value_type, 0, 0>&);
			void setMatrixPart(NumericalMatrix<value_type, 0, 0>&&);
			void setColumnPart(const NumericalVector<value_type, 0>&);
			void setColumnPart(NumericalVector<value_type, 0>&&);

		// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Operators

			NumericalVector<value_type, 0> operator()(const NumericalVector<value_type, 0>&) const;

			AffineMapping& operator*=(const NumericalMatrix<value_type, 0, 0>&);
			AffineMapping& operator*=(const AffineMapping&);

		// Operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Mathematical methods

			AffineMapping& transform(const NumericalMatrix<value_type, 0, 0>&);
			AffineMapping& transform(const AffineMapping&);
			AffineMapping& transform(const value_type scalingMultiplier, const NumericalMatrix<value_type, 0, 0>&);
			AffineMapping& transform(const value_type scalingMultiplier, const AffineMapping&);
			AffineMapping& multiply(const value_type scalingMultiplier, const NumericalMatrix<value_type, 0, 0>&);
			AffineMapping& multiply(const value_type scalingMultiplier, const AffineMapping&);

		// Mathematical methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Methods

			AffineMapping getInverse() const;
			bool isAvailable() const noexcept;

		// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************

		private:
			NumericalMatrix<value_type, 0, 0> _matrixPart;
			NumericalVector<value_type, 0> _columnPart;
		};
	}
}

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::AffineMapping() noexcept
	: _matrixPart{}
	, _columnPart{}
{
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::AffineMapping(const NumericalMatrix<T, 0, 0>& matrixPart)
	: _matrixPart{ matrixPart }
	, _columnPart{}
{
	if (_matrixPart.isEmpty())
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", "\"matrixPart\" is empty." };
	else
		_columnPart = NumericalVector<T, 0>(_matrixPart.columnSize());
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::AffineMapping(NumericalMatrix<T, 0, 0>&& matrixPart)
	: _matrixPart{ std::move(matrixPart) }
	, _columnPart{}
{
	if (_matrixPart.isEmpty())
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", "\"matrixPart\" is empty." };
	else
		_columnPart = NumericalVector<T, 0>(_matrixPart.columnSize());
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::AffineMapping(const NumericalMatrix<T, 0, 0>& matrixPart, const NumericalVector<T, 0>& columnPart)
	: _matrixPart{ matrixPart }
	, _columnPart{ columnPart }
{
	if (_matrixPart.isEmpty())
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", "\"matrixPart\" is empty." };

	else
	{
		if (_matrixPart.columnSize() != _columnPart.size())
			throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", "The column size of \"matrixPart\" is not equal to the size of \"columnPart\"." };
	}
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::AffineMapping(NumericalMatrix<T, 0, 0>&& matrixPart, NumericalVector<T, 0>&& columnPart)
	: _matrixPart{ std::move(matrixPart) }
	, _columnPart{ std::move(columnPart) }
{
	if (_matrixPart.isEmpty())
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", "\"matrixPart\" is empty." };

	else
	{
		if (_matrixPart.columnSize() != _columnPart.size())
			throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", "The column size of \"matrixPart\" is not equal to the size of \"translation\"." };
	}
}

// Constructors
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Property

template <typename T>
inline const MathToolkit::LinearAlgebra::NumericalMatrix<T, 0, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::matrixPart() const noexcept
{
	return _matrixPart;
}

template <typename T>
inline const MathToolkit::LinearAlgebra::NumericalVector<T, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::columnPart() const noexcept
{
	return _columnPart;
}

template <typename T>
inline void MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::setMatrixPart(const NumericalMatrix<T, 0, 0>& matrixPart)
{
	if ((_matrixPart.columnSize() == matrixPart.columnSize()) && (_matrixPart.rowSize() == matrixPart.rowSize()))
		_matrixPart = matrixPart;
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "setMatrixPart", "The column and/or row sizes are not the same as the old values." };
}

template <typename T>
inline void MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::setMatrixPart(NumericalMatrix<T, 0, 0>&& matrixPart)
{
	if ((_matrixPart.columnSize() == matrixPart.columnSize()) && (_matrixPart.rowSize() == matrixPart.rowSize()))
		_matrixPart = std::move(matrixPart);
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "setMatrixPart", "The column and/or row sizes are not the same as the old values." };
}

template <typename T>
inline void MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::setColumnPart(const NumericalVector<T, 0>& columnPart)
{
	if (_columnPart.size() == columnPart.size())
		_columnPart = columnPart;
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "setColumnPart", "Size is not the same as the old value." };
}

template <typename T>
inline void MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::setColumnPart(NumericalVector<T, 0>&& columnPart)
{
	if (_columnPart.size() == columnPart.size())
		_columnPart = std::move(columnPart);
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "setColumnPart", "Size is not the same as the old value." };
}

// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Unary operators

template <typename T>
inline MathToolkit::LinearAlgebra::NumericalVector<T, 0> MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::operator()(const NumericalVector<T, 0>& nv) const
{
	NumericalVector<T, 0> newNumericalVector{ _columnPart };
	newNumericalVector.add(_matrixPart, nv);
	return newNumericalVector;
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::operator*=(const NumericalMatrix<value_type, 0, 0>& nm)
{
	_matrixPart *= nm;
	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::operator*=(const AffineMapping& am)
{
	_matrixPart *= am._matrixPart;
	_columnPart.add(_matrixPart, am._columnPart);
	return *this;
}

// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Mathematical methods

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::transform(const NumericalMatrix<value_type, 0, 0>& nm)
{
	_matrixPart.transform(nm);
	_columnPart.transform(nm);
	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::transform(const AffineMapping& am)
{
	_matrixPart.transform(am._matrixPart);
	_columnPart.transform(am._matrixPart);
	_columnPart += am._columnPart;
	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::transform(const value_type scalingMultiplier, const NumericalMatrix<value_type, 0, 0>& nm)
{
	_matrixPart.transform(scalingMultiplier, nm);
	_columnPart.transform(nm);
	_columnPart *= scalingMultiplier;
	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::transform(const value_type scalingMultiplier, const AffineMapping& am)
{
	_matrixPart.transform(scalingMultiplier, am._matrixPart);
	_columnPart.transform(am._matrixPart);
	_columnPart += am._columnPart;
	_columnPart *= scalingMultiplier;
	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::multiply(const value_type scalingMultiplier, const NumericalMatrix<value_type, 0, 0>& nm)
{
	_matrixPart.multiply(scalingMultiplier, nm.matrixPart());
	return *this;
}

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>& MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::multiply(const value_type scalingMultiplier, const AffineMapping& am)
{
	_matrixPart.multiply(scalingMultiplier, am._matrixPart);
	_columnPart += scalingMultiplier * (_matrixPart * am._columnPart);
	return *this;
}

// Mathematical methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Methods

template <typename T>
inline MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0> MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::getInverse() const
{
	NumericalMatrix inverseMatrix = _matrixPart.getInverseMatrix();
	return AffineMapping{ inverseMatrix, ((-1.0) * inverseMatrix * _columnPart) };
}

template <typename T>
inline bool MathToolkit::LinearAlgebra::AffineMapping<T, 0, 0>::isAvailable() const noexcept
{
	return !(_matrixPart.isEmpty());
}

// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************


#endif // !MATHTOOLKIT_LINEARALGEBRA_AFFINEMAPPING_H
