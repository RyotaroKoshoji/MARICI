#ifndef MATHTOOLKIT_LINEARALGEBRA_FIXEDSIZENUMERICALVECTOR_H
#define MATHTOOLKIT_LINEARALGEBRA_FIXEDSIZENUMERICALVECTOR_H

#include <string>
#include <cmath>
#include <complex>

#include <array>
#include <initializer_list>
#include <numeric>

#include "ArgumentOutOfRangeException.h"


namespace MathToolkit
{
	namespace LinearAlgebra
	{
		template <typename T, unsigned short N>
		class NumericalVector final
		{
		public:
			using size_type = unsigned short;
			using value_type = T;
			using iterator = typename std::array<value_type, N>::iterator;
			using const_iterator = typename std::array<value_type, N>::const_iterator;

// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Constructors, destructor, and operators

		public:
			NumericalVector() noexcept;
			explicit NumericalVector(const value_type) noexcept;
			NumericalVector(std::initializer_list<value_type>);

			NumericalVector& operator=(const value_type scalar) noexcept;

			NumericalVector(const NumericalVector&) = default;
			NumericalVector(NumericalVector&&) noexcept = default;
			NumericalVector& operator=(const NumericalVector&) = default;
			NumericalVector& operator=(NumericalVector&&) noexcept = default;

			virtual ~NumericalVector() = default;

		// Constructors, destructor, and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Property

			value_type operator[](const size_type index) const noexcept;
			value_type& operator[](const size_type index) noexcept;
			value_type at(const size_type index) const;
			value_type& at(const size_type index);

			iterator begin() noexcept;
			const_iterator begin() const noexcept;
			iterator end() noexcept;
			const_iterator end() const noexcept;

			size_type size() const noexcept;

		// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Unary operators

			NumericalVector& operator+=(const NumericalVector&) noexcept;
			NumericalVector& operator-=(const NumericalVector&) noexcept;
			NumericalVector& operator*=(const value_type scalingMultiplier) noexcept;
			NumericalVector& operator/=(const value_type scalingDivider) noexcept;

		// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Arithmetic methods

			NumericalVector& add(const value_type scalingMultiplier, const NumericalVector&) noexcept;
			NumericalVector& add(const value_type scalingMultiplier, const NumericalVector&, const value_type selfScalingMultiplier) noexcept;

		// Arithmetic methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Utility

			double norm() const noexcept;
			double normSquare() const noexcept;

			void swap(NumericalVector&) noexcept;

		// Utility
// **********************************************************************************************************************************************************************************************************************************************************************************************

		private:
			std::array<value_type, N> _valueArray;
		};



		template <typename T, unsigned short N>
		inline NumericalVector<T, N> operator+(NumericalVector<T, N> nva, const NumericalVector<T, N>& nvb) noexcept
		{
			nva += nvb;
			return nva;
		}

		template <typename T, unsigned short N>
		inline NumericalVector<T, N> operator-(NumericalVector<T, N> nva, const NumericalVector<T, N>& nvb) noexcept
		{
			nva -= nvb;
			return nva;
		}

		template <typename T, unsigned short N>
		inline NumericalVector<T, N> operator*(const double scalingMultiplier, NumericalVector<T, N> nv) noexcept
		{
			nv *= scalingMultiplier;
			return nv;
		}

		template <typename T, unsigned short N>
		inline NumericalVector<T, N> operator/(NumericalVector<T, N> nv, const double scalingDivider) noexcept
		{
			nv /= scalingDivider;
			return nv;
		}

		template <typename T, unsigned short N>
		inline double getInnerProduct(const NumericalVector<T, N>& nva, const NumericalVector<T, N>& nvb) noexcept
		{
			return std::inner_product(nva.begin(), nva.end(), nvb.begin(), 0.0);
		}
	}
}

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors and operators

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>::NumericalVector() noexcept
	: _valueArray{}
{
	_valueArray.fill(value_type{ 0.0 });
}

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>::NumericalVector(const value_type value) noexcept
	: _valueArray{}
{
	_valueArray.fill(value);
}

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>::NumericalVector(std::initializer_list<value_type> init)
	: _valueArray{}
{
	if (init.size() == N)
	{
		auto thisIter = _valueArray.begin();

		for (auto iter = init.begin(); iter != init.end(); ++iter, ++thisIter)
			(*thisIter) = (*iter);
	}

	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", "The size of initializer_list is invalid." };
}

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>& MathToolkit::LinearAlgebra::NumericalVector<T, N>::operator=(const value_type scalar) noexcept
{
	_valueArray.fill(scalar);
	return *this;
}

// Constructors and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Property

template <typename T, unsigned short N>
inline T MathToolkit::LinearAlgebra::NumericalVector<T, N>::operator[](const size_type index) const noexcept
{
	return _valueArray[index];
}

template <typename T, unsigned short N>
inline T& MathToolkit::LinearAlgebra::NumericalVector<T, N>::operator[](const size_type index) noexcept
{
	return _valueArray[index];
}

template <typename T, unsigned short N>
inline T MathToolkit::LinearAlgebra::NumericalVector<T, N>::at(size_type index) const
{
	if (index < _valueArray.size())
		return _valueArray[index];
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "at", "\"index\" is out of range." };
}

template <typename T, unsigned short N>
inline T& MathToolkit::LinearAlgebra::NumericalVector<T, N>::at(size_type index)
{
	if (index < _valueArray.size())
		return _valueArray[index];
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "at", "\"index\" is out of range." };
}

template <typename T, unsigned short N>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, N>::iterator MathToolkit::LinearAlgebra::NumericalVector<T, N>::begin() noexcept
{
	return _valueArray.begin();
}

template <typename T, unsigned short N>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, N>::const_iterator MathToolkit::LinearAlgebra::NumericalVector<T, N>::begin() const noexcept
{
	return _valueArray.begin();
}

template <typename T, unsigned short N>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, N>::iterator MathToolkit::LinearAlgebra::NumericalVector<T, N>::end() noexcept
{
	return _valueArray.end();
}

template <typename T, unsigned short N>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, N>::const_iterator MathToolkit::LinearAlgebra::NumericalVector<T, N>::end() const noexcept
{
	return _valueArray.end();
}

template <typename T, unsigned short N>
inline typename MathToolkit::LinearAlgebra::NumericalVector<T, N>::size_type MathToolkit::LinearAlgebra::NumericalVector<T, N>::size() const noexcept
{
	return static_cast<unsigned short>(_valueArray.size());
}

// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Unary operators

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>& MathToolkit::LinearAlgebra::NumericalVector<T, N>::operator+=(const NumericalVector& numericalVector) noexcept
{
	for (size_type index = 0; index < N; ++index)
		_valueArray[index] += numericalVector._valueArray[index];

	return *this;
}

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>& MathToolkit::LinearAlgebra::NumericalVector<T, N>::operator-=(const NumericalVector& numericalVector) noexcept
{
	for (size_type index = 0; index < N; ++index)
		_valueArray[index] -= numericalVector._valueArray[index];

	return *this;
}

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>& MathToolkit::LinearAlgebra::NumericalVector<T, N>::operator*=(const value_type scalingMultiplier) noexcept
{
	for (size_type index = 0; index < N; ++index)
		_valueArray[index] *= scalingMultiplier;

	return *this;
}

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>& MathToolkit::LinearAlgebra::NumericalVector<T, N>::operator/=(const value_type scalingDivider) noexcept
{
	const value_type scalingMultiplier = (1.0 / scalingDivider);

	for (size_type index = 0; index < N; ++index)
		_valueArray[index] *= scalingMultiplier;

	return *this;
}

// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Arithmetic methods

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>& MathToolkit::LinearAlgebra::NumericalVector<T, N>::add(const value_type scalingMultiplier, const NumericalVector& numericalVector) noexcept
{
	for (size_type index = 0; index < N; ++index)
		_valueArray[index] += (numericalVector._valueArray[index]  * scalingMultiplier);

	return *this;
}

template <typename T, unsigned short N>
inline MathToolkit::LinearAlgebra::NumericalVector<T, N>& MathToolkit::LinearAlgebra::NumericalVector<T, N>::add(const value_type scalingMultiplier, const NumericalVector& numericalVector, const value_type selfScalingMultiplier) noexcept
{
	for (size_type index = 0; index < N; ++index)
	{
		_valueArray[index] *= selfScalingMultiplier;
		_valueArray[index] += (numericalVector._valueArray[index] * scalingMultiplier);
	}

	return *this;
}

// Arithmetic methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Utility

template <typename T, unsigned short N>
inline double MathToolkit::LinearAlgebra::NumericalVector<T, N>::norm() const noexcept
{
	return std::sqrt(normSquare());
}

template <typename T, unsigned short N>
inline double MathToolkit::LinearAlgebra::NumericalVector<T, N>::normSquare() const noexcept
{
	double result{ 0.0 };
	{
		for (const auto value : _valueArray)
		{
			double absValue = std::abs(value);
			result += (absValue * absValue);
		}
	}

	return result;
}

template <typename T, unsigned short N>
inline void MathToolkit::LinearAlgebra::NumericalVector<T, N>::swap(NumericalVector& nv) noexcept
{
	_valueArray.swap(nv._valueArray);
}

// Utility
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************


#endif // !MATHTOOLKIT_LINEARALGEBRA_FIXEDSIZENUMERICALVECTOR_H
