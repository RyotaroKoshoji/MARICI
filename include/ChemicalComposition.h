#ifndef CHEMTOOLKIT_GENERIC_CHEMICALCOMPOSITION_H
#define CHEMTOOLKIT_GENERIC_CHEMICALCOMPOSITION_H

#include <algorithm>
#include <string>
#include <map>
#include <numeric>
#include <vector>

#include "InvalidOperationException.h"

#include "ChemicalSystem.h"


namespace ChemToolkit
{
	namespace Generic
	{
		template <typename A>
		class ChemicalComposition
		{
		public:
			using AtomicSpecies = A;
			using size_type = typename A::size_type;

			using iterator = typename std::map<AtomicSpecies, size_type>::iterator;
			using const_iterator = typename std::map<AtomicSpecies, size_type>::const_iterator;


			struct Hasher
			{
				std::size_t operator()(const ChemicalComposition&) const;
			};

// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Constructors, destructor, and operators

		public:
			ChemicalComposition() noexcept = default;
			virtual ~ChemicalComposition() = default;

			ChemicalComposition(const ChemicalComposition&) = default;
			ChemicalComposition(ChemicalComposition&&) noexcept = default;
			ChemicalComposition& operator=(const ChemicalComposition&) = default;
			ChemicalComposition& operator=(ChemicalComposition&&) noexcept = default;

		// Constructors, destructor, and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Property

			iterator begin() noexcept;
			const_iterator begin() const noexcept;
			iterator end() noexcept;
			const_iterator end() const noexcept;

		// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Methods

			size_type count() const;
			size_type count(const AtomicSpecies&) const;
			size_type countAtomicSpecies() const noexcept;

			bool contains(const AtomicSpecies&) const;
			bool isEmpty() const noexcept;
			void clear() noexcept;

			std::size_t getHashCode() const;

			void add(const AtomicSpecies&, const size_type numAtoms = 1);
			void erase(const AtomicSpecies&);
			void join(const ChemicalComposition&);

		// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Utility

			std::string toString() const;

			ChemicalSystem<AtomicSpecies> toChemicalSystem() const;
			ChemicalComposition toReducedChemicalComposition() const;

		// Utility
// **********************************************************************************************************************************************************************************************************************************************************************************************

		private:
			std::map<AtomicSpecies, size_type> _dictionary;
		};



		template <typename A>
		std::size_t ChemicalComposition<A>::Hasher::operator()(const ChemicalComposition& cc) const
		{
			return cc.getHashCode();
		}

		template <typename A>
		inline bool operator<(const ChemicalComposition<A>& cca, const ChemicalComposition<A>& ccb)
		{
			if (cca.count() < ccb.count())
				return true;
			else if (cca.count() > ccb.count())
				return false;
			else
				return std::lexicographical_compare(cca.begin(), cca.end(), ccb.begin(), ccb.end());
		}

		template <typename A>
		inline bool operator>(const ChemicalComposition<A>& cca, const ChemicalComposition<A>& ccb)
		{
			return (ccb < cca);
		}

		template <typename A>
		inline bool operator==(const ChemicalComposition<A>& cca, const ChemicalComposition<A>& ccb)
		{
			return std::equal(cca.begin(), cca.end(), ccb.begin(), ccb.end());
		}

		template <typename A>
		inline bool operator!=(const ChemicalComposition<A>& cca, const ChemicalComposition<A>& ccb)
		{
			return !(cca == ccb);
		}
	}
}

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Property

template <typename A>
inline typename ChemToolkit::Generic::ChemicalComposition<A>::iterator ChemToolkit::Generic::ChemicalComposition<A>::begin() noexcept
{
	return _dictionary.begin();
}

template <typename A>
inline typename ChemToolkit::Generic::ChemicalComposition<A>::const_iterator ChemToolkit::Generic::ChemicalComposition<A>::begin() const noexcept
{
	return _dictionary.begin();
}

template <typename A>
inline typename ChemToolkit::Generic::ChemicalComposition<A>::iterator ChemToolkit::Generic::ChemicalComposition<A>::end() noexcept
{
	return _dictionary.end();
}

template <typename A>
inline typename ChemToolkit::Generic::ChemicalComposition<A>::const_iterator ChemToolkit::Generic::ChemicalComposition<A>::end() const noexcept
{
	return _dictionary.end();
}

// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Methods

template <typename A>
inline typename ChemToolkit::Generic::ChemicalComposition<A>::size_type ChemToolkit::Generic::ChemicalComposition<A>::count() const
{
	size_type numAtoms = 0;
	{
		for (const auto& speciesAndCount : _dictionary)
			numAtoms += speciesAndCount.second;
	}

	return numAtoms;
}

template <typename A>
inline typename ChemToolkit::Generic::ChemicalComposition<A>::size_type ChemToolkit::Generic::ChemicalComposition<A>::count(const A& atomicSpecies) const
{
	auto iter = _dictionary.find(atomicSpecies);

	if (iter == _dictionary.end())
		return 0;
	else
		return iter->second;
}

template <typename A>
inline typename ChemToolkit::Generic::ChemicalComposition<A>::size_type ChemToolkit::Generic::ChemicalComposition<A>::countAtomicSpecies() const noexcept
{
	return static_cast<size_type>(_dictionary.size());
}

template <typename A>
inline bool ChemToolkit::Generic::ChemicalComposition<A>::contains(const A& atomicSpecies) const
{
	return !(_dictionary.find(atomicSpecies) == _dictionary.end());
}

template <typename A>
inline bool ChemToolkit::Generic::ChemicalComposition<A>::isEmpty() const noexcept
{
	return _dictionary.empty();
}

template <typename A>
inline void ChemToolkit::Generic::ChemicalComposition<A>::clear() noexcept
{
	_dictionary.clear();
}

template <typename A>
inline std::size_t ChemToolkit::Generic::ChemicalComposition<A>::getHashCode() const
{
	std::string hashName;
	{
		for (const auto& speciesAndCount : _dictionary)
		{
			hashName += speciesAndCount.first.toHashString();
			hashName += "_";
			hashName += std::to_string(speciesAndCount.second);
			hashName += "_";
		}
	}

	return std::hash<std::string>{}(hashName);
}

template <typename A>
inline void ChemToolkit::Generic::ChemicalComposition<A>::add(const A& atomicSpecies, const size_type numAtoms)
{
	auto iter = _dictionary.find(atomicSpecies);

	if (iter == _dictionary.end())
		_dictionary.emplace(atomicSpecies, numAtoms);
	else
		iter->second += numAtoms;
}

template <typename A>
inline void ChemToolkit::Generic::ChemicalComposition<A>::erase(const A& atomicSpecies)
{
	_dictionary.erase(atomicSpecies);
}

template <typename A>
inline void ChemToolkit::Generic::ChemicalComposition<A>::join(const ChemicalComposition& chemicalComposition)
{
	for (const auto& speciesAndCount : chemicalComposition._dictionary)
		add(speciesAndCount.first, speciesAndCount.second);
}

// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Utility

template <typename A>
inline std::string ChemToolkit::Generic::ChemicalComposition<A>::toString() const
{
	if (!(isEmpty()))
	{
		std::string compositionName;
		{
			for (const auto& speciesAndCount : _dictionary)
			{
				compositionName += speciesAndCount.first.toElementSymbol();
				compositionName += "_";
				compositionName += std::to_string(speciesAndCount.second);
				compositionName += "_";
			}

			compositionName.pop_back();
		}

		return compositionName;
	}

	else
		throw System::ExceptionServices::InvalidOperationException{ typeid(*this), "toString", "This is invalid." };
}

template <typename T>
inline ChemToolkit::Generic::ChemicalSystem<T> ChemToolkit::Generic::ChemicalComposition<T>::toChemicalSystem() const
{
	ChemicalSystem<T> chemicalSystem;
	{
		for (const auto& speciesAndCount : _dictionary)
			chemicalSystem.add(speciesAndCount.first);
	}

	return chemicalSystem;
}

template <typename T>
inline ChemToolkit::Generic::ChemicalComposition<T> ChemToolkit::Generic::ChemicalComposition<T>::toReducedChemicalComposition() const
{
	if (!(isEmpty()))
	{
		ChemicalComposition reducedChemicalComposition;
		reducedChemicalComposition._dictionary = _dictionary;
		{
			int greatestCommonDivider{ 0 };
			{
				std::vector<int> atomCounts;
				{
					for (const auto& speciesAndCount : _dictionary)
						atomCounts.push_back(static_cast<int>(speciesAndCount.second));
				}

				greatestCommonDivider = std::accumulate(atomCounts.begin(), atomCounts.end(), 0, [](const int a, const int b) { return std::gcd(a, b); });
			}

			for (auto& speciesAndCount : reducedChemicalComposition._dictionary)
				speciesAndCount.second /= greatestCommonDivider;
		}

		return reducedChemicalComposition;
	}

	else
		throw System::ExceptionServices::InvalidOperationException{ typeid(*this), "getReducedChemicalComposition", "This is invalid." };
}

// Utility
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************


#endif // !CHEMTOOLKIT_GENERIC_CHEMICALCOMPOSITION_H
