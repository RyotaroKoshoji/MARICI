#ifndef MATHTOOLKIT_LINEARALGEBRA_NUMERICALSYMMETRICMATRIX_H
#define MATHTOOLKIT_LINEARALGEBRA_NUMERICALSYMMETRICMATRIX_H

#include <string>
#include <type_traits>
#include <initializer_list>
#include <algorithm>
#include <limits>
#include <complex>
#include <valarray>
#include <cmath>
#include <utility>
#include <vector>

#include "ArgumentOutOfRangeException.h"

#include "NumericalVector.h"


namespace MathToolkit
{
	namespace LinearAlgebra
	{
		/*
		Column Major Layout for _columnSize-by-_rowSize matrix
		*/

		class NumericalSymmetricMatrix final
		{
		public:
			using size_type = std::size_t;
			using value_type = double;

// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Constructors, operators, and destructor

		public:
			NumericalSymmetricMatrix() noexcept;
			explicit NumericalSymmetricMatrix(const size_type dimension);
			NumericalSymmetricMatrix(const size_type dimension, const value_type);

			NumericalSymmetricMatrix& operator=(const value_type scalar) noexcept;

			NumericalSymmetricMatrix(const NumericalSymmetricMatrix&) = default;
			NumericalSymmetricMatrix(NumericalSymmetricMatrix&&) noexcept = default;
			NumericalSymmetricMatrix& operator=(const NumericalSymmetricMatrix&) = default;
			NumericalSymmetricMatrix& operator=(NumericalSymmetricMatrix&&) noexcept = default;

			virtual ~NumericalSymmetricMatrix() = default;

		// Constructors, operators, and destructor
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Property

			value_type operator()(const size_type rowIndex, const size_type columnIndex) const noexcept;
			value_type& operator()(const size_type rowIndex, const size_type columnIndex) noexcept;
			value_type at(const size_type rowIndex, const size_type columnIndex) const;
			value_type& at(const size_type rowIndex, const size_type columnIndex);

			size_type dimension() const noexcept;

		// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Unary operators

			NumericalSymmetricMatrix& operator+=(const NumericalSymmetricMatrix&);
			NumericalSymmetricMatrix& operator-=(const NumericalSymmetricMatrix&);
			NumericalSymmetricMatrix& operator*=(const value_type scalingMultiplier);
			NumericalSymmetricMatrix& operator/=(const value_type scalingDivider);

		// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Mathematical methods

			NumericalSymmetricMatrix& add(const value_type scalingMultiplier, const NumericalSymmetricMatrix&);
			NumericalSymmetricMatrix& add(const value_type scalingMultiplier, const NumericalSymmetricMatrix&, const value_type selfScalingMultiplier);

			NumericalSymmetricMatrix& invert();
			NumericalSymmetricMatrix getInverseMatrix() const;

			std::vector<NumericalVector<value_type, 0>> getEigenVectors() const;
			std::vector<std::pair<value_type, NumericalVector<value_type, 0>>> getEigenValueAndVectors() const;

		// Mathematical methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Utility

			void swap(NumericalSymmetricMatrix&) noexcept;
			void resize(const size_type dimension, const value_type value = value_type{});
			void clear() noexcept;

			bool isEmpty() const noexcept;
			bool isSame(const NumericalSymmetricMatrix&, const double valuePrecision = std::numeric_limits<double>::epsilon()) const noexcept;

			value_type getTrace() const noexcept;

		// Utility
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
		// Private methods

		private:
			size_type getIndex(const size_type rowIndex, const size_type columnIndex) const noexcept;

		// Private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************

		private:
			std::valarray<value_type> _valueArray;
			size_type _dimension;
		};


		inline NumericalSymmetricMatrix getIdentitySymmetricMatrix(const std::size_t rank)
		{
			NumericalSymmetricMatrix identityMatrix(rank);
			{
				for (std::size_t index = 0; index < rank; ++index)
					identityMatrix(index, index) = 1.0;
			}

			return identityMatrix;
		}
	}
}

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors and operators

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::NumericalSymmetricMatrix() noexcept
	: _valueArray{}
	, _dimension{ 0 }
{
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::NumericalSymmetricMatrix(const size_type dimension)
	: _valueArray(0.0, ((dimension* (dimension + 1)) / 2))
	, _dimension{ dimension }
{
	if (_dimension == 0)
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", "\"dimension\" is zero." };
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::NumericalSymmetricMatrix(const size_type dimension, const value_type value)
	: _valueArray(value, ((dimension* (dimension + 1)) / 2))
	, _dimension{ dimension }
{
	if (_dimension == 0)
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", "\"dimension\" is zero." };
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix& MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::operator=(const value_type scalar) noexcept
{
	_valueArray = scalar;
	return *this;
}

// Constructors and operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Property

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::value_type MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::operator()(const size_type rowIndex, const size_type columnIndex) const noexcept
{
	return _valueArray[getIndex(rowIndex, columnIndex)];
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::value_type& MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::operator()(const size_type rowIndex, const size_type columnIndex) noexcept
{
	return _valueArray[getIndex(rowIndex, columnIndex)];
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::value_type MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::at(const size_type rowIndex, const size_type columnIndex) const
{
	if (rowIndex < _dimension && columnIndex < _dimension)
		return _valueArray[getIndex(rowIndex, columnIndex)];
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "at", "Index is out of range." };
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::value_type& MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::at(const size_type rowIndex, const size_type columnIndex)
{
	if (rowIndex < _dimension && columnIndex < _dimension)
		return _valueArray[getIndex(rowIndex, columnIndex)];
	else
		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "at", "Index is out of range." };
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::size_type MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::dimension() const noexcept
{
	return _dimension;
}

// Property
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Unary operators

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix& MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::operator+=(const NumericalSymmetricMatrix& numericalMatrix)
{
	_valueArray += numericalMatrix._valueArray;
	return *this;
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix& MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::operator-=(const NumericalSymmetricMatrix& numericalMatrix)
{
	_valueArray -= numericalMatrix._valueArray;
	return *this;
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix& MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::operator*=(const value_type scalingMultiplier)
{
	_valueArray *= scalingMultiplier;
	return *this;
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix& MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::operator/=(const value_type scalingDivider)
{
	const value_type scalingMultiplier = (1.0 / scalingDivider);
	_valueArray *= scalingMultiplier;
	return *this;
}

// Unary operators
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Mathematical methods

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix& MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::add(const value_type scalingMultiplier, const NumericalSymmetricMatrix& numericalMatrix)
{
	auto iter = std::begin(numericalMatrix._valueArray);

	for (auto& value : _valueArray)
	{
		value += (*iter) * scalingMultiplier;
		++iter;
	}

	return *this;
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix& MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::add(const value_type scalingMultiplier, const NumericalSymmetricMatrix& numericalMatrix, const value_type selfScalingMultiplier)
{
	auto iter = std::begin(numericalMatrix._valueArray);

	for (auto& value : _valueArray)
	{
		value *= selfScalingMultiplier;
		value += (*iter) * scalingMultiplier;
		++iter;
	}

	return *this;
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::getInverseMatrix() const
{
	NumericalSymmetricMatrix inverseMatrix{ *this };
	inverseMatrix.invert();
	return inverseMatrix;
}

inline std::vector<MathToolkit::LinearAlgebra::NumericalVector<double, 0>> MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::getEigenVectors() const
{
	std::vector<MathToolkit::LinearAlgebra::NumericalVector<value_type, 0>> eigenVectors;
	{
		for (const auto& eigenvalueAndVector : getEigenValueAndVectors())
			eigenVectors.push_back(eigenvalueAndVector.second);
	}

	return std::vector<NumericalVector<value_type, 0>>{};
}

// Mathematical methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Utility

inline void MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::swap(NumericalSymmetricMatrix& nm) noexcept
{
	_valueArray.swap(nm._valueArray);
	std::swap(_dimension, nm._dimension);
}

inline void MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::resize(const size_type dimension, const value_type value)
{
	_dimension = dimension;
	_valueArray.resize(((dimension * (dimension + 1)) / 2), value);
}

inline void MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::clear() noexcept
{
	std::valarray<value_type> va;
	_valueArray.swap(va);
	_dimension = 0;
}

inline bool MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::isEmpty() const noexcept
{
	return !(static_cast<bool>(_valueArray.size()));
}

inline bool MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::isSame(const NumericalSymmetricMatrix& nm, const double valuePrecision) const noexcept
{
	if (_dimension == nm._dimension)
	{
		auto otherIter = std::begin(nm._valueArray);

		for (auto thisIter = std::begin(_valueArray); thisIter != std::end(_valueArray); ++thisIter)
		{
			double differenceSquare = 0.0;
			{
				value_type difference = ((*otherIter) - (*thisIter));
				differenceSquare += (difference * difference);
			}

			if (differenceSquare < (valuePrecision * valuePrecision))
				++otherIter;
			else
				return false;
		}

		return true;
	}

	else
		return false;
}

inline MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::value_type MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::getTrace() const noexcept
{
	value_type value = 0.0;
	{
		for (size_type rowIndex = 0; rowIndex < _dimension; ++rowIndex)
			value += operator()(rowIndex, rowIndex);
	}

	return value;
}

// Utility
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private methods

inline std::size_t MathToolkit::LinearAlgebra::NumericalSymmetricMatrix::getIndex(const size_type rowIndex, const size_type columnIndex) const noexcept
{
	if (columnIndex < rowIndex)
	{
		size_type index = columnIndex;
		index += ((rowIndex * (rowIndex + 1)) / 2);
		return index;
	}

	else
	{
		size_type index = rowIndex;
		index += ((columnIndex * (columnIndex + 1)) / 2);
		return index;
	}
}

// Private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************

#endif // !MATHTOOLKIT_LINEARALGEBRA_NUMERICALSYMMETRICMATRIX_H
