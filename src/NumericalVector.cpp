#include "NumericalVector.h"

#include "NumericalVectorSlice.h"
#include "NumericalMatrix.h"


using namespace MathToolkit::LinearAlgebra;

// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors

template <>
NumericalVector<double, 0>::NumericalVector(const NumericalVectorSlice<double>& numericalVectorSlice)
	: NumericalVector(numericalVectorSlice.size())
{
	auto thisIter = std::begin(_valueArray);

	for (size_type index = 0; index < numericalVectorSlice.size(); ++index)
	{
		(*thisIter) = numericalVectorSlice[index];
		++thisIter;
	}
}

template <>
MathToolkit::LinearAlgebra::NumericalVector<std::complex<double>, 0>::NumericalVector(const NumericalVectorSlice<std::complex<double>>& numericalVectorSlice)
	: NumericalVector(numericalVectorSlice.size())
{
	auto thisIter = std::begin(_valueArray);

	for (size_type index = 0; index < numericalVectorSlice.size(); ++index)
	{
		(*thisIter) = numericalVectorSlice[index];
		++thisIter;
	}
}

template <>
NumericalVector<double, 0>& NumericalVector<double, 0>::operator=(const NumericalVectorSlice<double>& numericalVectorSlice)
{
	_valueArray.resize(numericalVectorSlice.size());
	auto thisIter = std::begin(_valueArray);
	{
		for (size_type index = 0; index < numericalVectorSlice.size(); ++index)
		{
			(*thisIter) = numericalVectorSlice[index];
			++thisIter;
		}
	}

	return *this;
}

template <>
NumericalVector<std::complex<double>, 0>& NumericalVector<std::complex<double>, 0>::operator=(const NumericalVectorSlice<std::complex<double>>& numericalVectorSlice)
{
	_valueArray.resize(numericalVectorSlice.size());
	auto thisIter = std::begin(_valueArray);
	{
		for (size_type index = 0; index < numericalVectorSlice.size(); ++index)
		{
			(*thisIter) = numericalVectorSlice[index];
			++thisIter;
		}
	}

	return *this;
}

// Constructors
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Arithmetic methods

template <>
NumericalVector<double, 0>& NumericalVector<double, 0>::add(const NumericalMatrix<double, 0, 0>& numericalMatrix, const NumericalVector& nv)
{
	auto matrixIter = numericalMatrix.begin();
	{
		for (const auto& val : nv)
		{
			auto thisIter = std::begin(_valueArray);

			for (size_type rowIndex = 0; rowIndex < numericalMatrix.columnSize(); ++rowIndex)
			{
				(*thisIter) += (*matrixIter) * val;
				++thisIter;
				++matrixIter;
			}
		}
	}

	return *this;
}

template <>
NumericalVector<std::complex<double>, 0>& NumericalVector<std::complex<double>, 0>::add(const NumericalMatrix<std::complex<double>, 0, 0>& numericalMatrix, const NumericalVector& nv)
{
	auto matrixIter = numericalMatrix.begin();
	{
		for (const auto& val : nv)
		{
			auto thisIter = std::begin(_valueArray);

			for (size_type rowIndex = 0; rowIndex < numericalMatrix.columnSize(); ++rowIndex)
			{
				(*thisIter) += (*matrixIter) * val;
				++thisIter;
				++matrixIter;
			}
		}
	}

	return *this;
}

template <>
NumericalVector<double, 0>& NumericalVector<double, 0>::transform(const NumericalMatrix<double, 0, 0>& numericalMatrix)
{
	std::valarray<value_type> newValueArray(0.0, numericalMatrix.columnSize());
	{
		auto matrixIter = numericalMatrix.begin();
		{
			for (const auto& val : _valueArray)
			{
				auto newIter = std::begin(newValueArray);

				for (size_type rowIndex = 0; rowIndex < numericalMatrix.columnSize(); ++rowIndex)
				{
					(*newIter) += (*matrixIter) * val;
					++newIter;
					++matrixIter;
				}
			}
		}
	}

	_valueArray.swap(newValueArray);
	return *this;
}

template <>
NumericalVector<std::complex<double>, 0>& NumericalVector<std::complex<double>, 0>::transform(const NumericalMatrix<std::complex<double>, 0, 0>& numericalMatrix)
{
	std::valarray<value_type> newValueArray(0.0, numericalMatrix.columnSize());
	{
		auto matrixIter = numericalMatrix.begin();
		{
			for (const auto& val : _valueArray)
			{
				auto newIter = std::begin(newValueArray);

				for (size_type rowIndex = 0; rowIndex < numericalMatrix.columnSize(); ++rowIndex)
				{
					(*newIter) += (*matrixIter) * val;
					++newIter;
					++matrixIter;
				}
			}
		}
	}

	_valueArray.swap(newValueArray);
	return *this;
}

// Arithmetic methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
