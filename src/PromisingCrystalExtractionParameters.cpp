#include "PromisingCrystalExtractionParameters.h"

#include <limits>

#include "InvalidFileException.h"

#include "LengthCasting.h"

#include "CrystalExtractionTask.h"

using namespace MathematicalCrystalChemistry::Analysis;


// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors

double PromisingCrystalExtractionParameters::s_defaultSpaceGroupPrecision{ MathematicalCrystalChemistry::Extraction::CrystalExtractionTask::defaultSpaceGroupPrecision() };



PromisingCrystalExtractionParameters::PromisingCrystalExtractionParameters() noexcept
	: _needExtraction{ false }
	, _identifySiteLabel{ true }
	, _identifySiteSymmetry{ true }
	, _identifyCoordinations{ true }
	, _identifyCoordinationPolyhedraLinkings{ true }
	, _spaceGroupPrecision{ s_defaultSpaceGroupPrecision }
	, _feasibleSpaceGroupRange{ SpaceGroupNumber{ 1 }, SpaceGroupNumber{ 230 } }
	, _maximumAtomicEnvironments{ std::numeric_limits<size_type>::max() }
	, _maximumAnionicEnvironments{ std::numeric_limits<size_type>::max() }
	, _maximumCationicEnvironments{ std::numeric_limits<size_type>::max() }
	, _maximumAtomicEnvironmentsPerElement{ std::numeric_limits<size_type>::max() }
	, _maximumAtomicEnvironmentsPerAnionicElement{ std::numeric_limits<size_type>::max() }
	, _maximumAtomicEnvironmentsPerCationicElement{ std::numeric_limits<size_type>::max() }
{
}

// Constructors
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Methods

void PromisingCrystalExtractionParameters::initialize() noexcept
{
	_needExtraction = false;

	_identifySiteLabel = true;
	_identifySiteSymmetry = true;
	_identifyCoordinations = true;
	_identifyCoordinationPolyhedraLinkings = true;

	_spaceGroupPrecision = s_defaultSpaceGroupPrecision;
	_feasibleSpaceGroupRange = std::make_pair(SpaceGroupNumber{ 1 }, SpaceGroupNumber{ 230 });

	_maximumAtomicEnvironments = std::numeric_limits<size_type>::max();
	_maximumAnionicEnvironments = std::numeric_limits<size_type>::max();
	_maximumCationicEnvironments = std::numeric_limits<size_type>::max();

	_maximumAtomicEnvironmentsPerElement = std::numeric_limits<size_type>::max();
	_maximumAtomicEnvironmentsPerAnionicElement = std::numeric_limits<size_type>::max();
	_maximumAtomicEnvironmentsPerCationicElement = std::numeric_limits<size_type>::max();
}

void PromisingCrystalExtractionParameters::initialize(const System::IO::StreamReader& inputStreamReader)
{
	System::IO::StreamReader genericStreamReader = inputStreamReader.getListBlock("&", "CRYSTAL_EXTRACTION_GENERIC");
	{
		std::string necessityTexts;

		if (genericStreamReader.readParameter("Promising.Crystals.Extraction", necessityTexts))
			_needExtraction = toNecessity(necessityTexts);
		else
			_needExtraction = false;
	}


	{
		std::string identifySiteLabelText;

		if (genericStreamReader.readParameter("Identify.Site.Label", identifySiteLabelText))
			_identifySiteLabel = toNecessity(identifySiteLabelText);
	}
	{
		std::string identifySiteSymmetryText;

		if (genericStreamReader.readParameter("Identify.Site.Symmetry", identifySiteSymmetryText))
			_identifySiteSymmetry = toNecessity(identifySiteSymmetryText);
	}
	{
		std::string identifyCoordinationNumberText;

		if (genericStreamReader.readParameter("Identify.Coordinations", identifyCoordinationNumberText))
			_identifyCoordinations = toNecessity(identifyCoordinationNumberText);
	}
	{
		std::string identifyCoordinationPolyhedraLinkingsText;

		if (genericStreamReader.readParameter("Identify.Coordination.Polyhedra.Linkings", identifyCoordinationPolyhedraLinkingsText))
			_identifyCoordinationPolyhedraLinkings = toNecessity(identifyCoordinationPolyhedraLinkingsText);
	}


	{
		using namespace MathToolkit::UnitConversion;
		double precisionAngstrom = 0.0;

		if (genericStreamReader.readParameter("Space.Group.Precision", precisionAngstrom))
			_spaceGroupPrecision = LengthCasting::cast<LengthCasting::Unit::Angstrom, LengthCasting::Unit::AtomicUnit>(precisionAngstrom);
		else
			_spaceGroupPrecision = s_defaultSpaceGroupPrecision;
	}
	{
		std::pair<size_type, size_type> range;

		if (genericStreamReader.readParameter("Feasible.Space.Group.Range", range))
			_feasibleSpaceGroupRange = std::make_pair(SpaceGroupNumber{ range.first }, SpaceGroupNumber{ range.second });
		else
			_feasibleSpaceGroupRange = std::make_pair(SpaceGroupNumber{ 1 }, SpaceGroupNumber{ 230 });
	}


	{
		if (!(genericStreamReader.readParameter("Maximum.Number.of.Atomic.Environments", _maximumAtomicEnvironments)))
			_maximumAtomicEnvironments = std::numeric_limits<size_type>::max();
	}
	{
		if (!(genericStreamReader.readParameter("Maximum.Number.of.Anionic.Environments", _maximumAnionicEnvironments)))
			_maximumAnionicEnvironments = std::numeric_limits<size_type>::max();
	}
	{
		if (!(genericStreamReader.readParameter("Maximum.Number.of.Cationic.Environments", _maximumCationicEnvironments)))
			_maximumCationicEnvironments = std::numeric_limits<size_type>::max();
	}


	{
		if (!(genericStreamReader.readParameter("Maximum.Number.of.Atomic.Environments.Per.Element", _maximumAtomicEnvironmentsPerElement)))
			_maximumAtomicEnvironmentsPerElement = std::numeric_limits<size_type>::max();
	}
	{
		if (!(genericStreamReader.readParameter("Maximum.Number.of.Atomic.Environments.Per.Anionic.Element", _maximumAtomicEnvironmentsPerAnionicElement)))
			_maximumAtomicEnvironmentsPerAnionicElement = std::numeric_limits<size_type>::max();
	}
	{
		if (!(genericStreamReader.readParameter("Maximum.Number.of.Atomic.Environments.Per.Cationic.Element", _maximumAtomicEnvironmentsPerCationicElement)))
			_maximumAtomicEnvironmentsPerCationicElement = std::numeric_limits<size_type>::max();
	}


	validate();
}

// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private methods

bool PromisingCrystalExtractionParameters::toNecessity(const std::string& inputTexts) const
{
	if (inputTexts == "ON" || inputTexts == "On" || inputTexts == "on")
		return true;

	else if (inputTexts == "OFF" || inputTexts == "Off" || inputTexts == "off")
		return false;

	else
		throw System::IO::InvalidFileException{ typeid(*this), "toNecessity", "Could not read necessity texts." };
}

void PromisingCrystalExtractionParameters::validate() const
{
	if (_feasibleSpaceGroupRange.second < _feasibleSpaceGroupRange.first)
		throw System::IO::InvalidFileException{ typeid(*this), "validate", "Maximum value of Feasible.Space.Group.Range is less than the minimum." };
}

// Private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
