#include "ExtractCrystals.h"

#include <iostream>
#include <vector>

#include "ThreadingPolicy.h"

#include "File.h"
#include "Directory.h"
#include "InvalidFileException.h"

#include "CifStreamReader.h"
#include "CifStreamWriter.h"

using namespace MathematicalCrystalChemistry::Extraction::Internal;


// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors

std::string ExtractCrystals::s_fingerprintFilename{ "fingerprint.txt" };
std::mutex ExtractCrystals::s_outputMutex;
double ExtractCrystals::s_defaultFeasibleErrorRate{ 0.05 };



ExtractCrystals::ExtractCrystals(const size_type rank) noexcept
	: _threadRank{ rank }
	, _inputCrystalsDirectoryPath{}
	, _outputCrystalsDirectoryPath{}
	, _spaceGroupPrecision{ CrystalExtractionTask::defaultSpaceGroupPrecision() }
	, _feasibleErrorRate{ s_defaultFeasibleErrorRate }
	, _geometricalConstraintParameters{}
	, _crystalOptimalityAnalyzer{}
	, _isotypicCrystalExtractor{}
	, _promisingCrystalExtractor{}
{
}

// Constructors
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Methods

void ExtractCrystals::operator()() const
{
	std::queue<std::filesystem::path> cifFilePaths = getCifFilePaths();
	eraseFilePathsInitially(cifFilePaths);


	while (!(cifFilePaths.empty()))
	{
		std::filesystem::path cifFilePath = cifFilePaths.front();

		try
		{
			ChemToolkit::Crystallography::IO::CifStreamReader cifStreamReader{ cifFilePath };
			OptimalCrystalStructure optimalCrystalStructure{ cifStreamReader.readCrystallographicStructure() };
			optimalCrystalStructure.simplifyStructure();
			{
				using MathematicalCrystalChemistry::CrystalModel::Components::ConstrainingCrystalStructure;

				ConstrainingCrystalStructure constrainingCrystalStructure{ optimalCrystalStructure };
				constrainingCrystalStructure.setFeasibleErrorRate(_feasibleErrorRate);
				constrainingCrystalStructure.setExclusiveRadiusRatio(_geometricalConstraintParameters.minimumExclusionDistanceRatio());
				constrainingCrystalStructure.setInteratomicDistanceTracerCutoffRatio(_geometricalConstraintParameters.interatomicDistanceTracerCutoffRatio());
				constrainingCrystalStructure.setInteratomicDistanceConstrainerCutoffRatio(_geometricalConstraintParameters.interatomicDistanceConstrainerCutoffRatio());
				constrainingCrystalStructure.updateTracingIndexPairs();
				constrainingCrystalStructure.createInteratomicDistanceConstraints();
				//constrainingCrystalStructure.eraseInfeasibleChemicalBonds();

				optimalCrystalStructure.import(constrainingCrystalStructure);
			}


			if (_isotypicCrystalExtractor.crystalIdentificationParameters().needExtraction())
			{
				if (!(_isotypicCrystalExtractor.isRegisteredCrystal(optimalCrystalStructure)))
				{
					eraseFilePathsForParallel(cifFilePaths);
					continue;
				}
			}

			if (_crystalOptimalityAnalyzer.isActive())
			{
				if (!(_crystalOptimalityAnalyzer.isFeasible(optimalCrystalStructure)))
				{
					eraseFilePathsForParallel(cifFilePaths);
					continue;
				}
			}

			if (_promisingCrystalExtractor.promisingCrystalExtractionParameters().needExtraction())
			{
				OptimalCrystalStructure conventionalOptimalStructure = optimalCrystalStructure;
				conventionalOptimalStructure.conventionalizeStructure(_spaceGroupPrecision);


				if (!(_promisingCrystalExtractor.isPromising(conventionalOptimalStructure)))
				{
					eraseFilePathsForParallel(cifFilePaths);
					continue;
				}
			}


			std::lock_guard<std::mutex> guard{ s_outputMutex };
			outputOptimalCrystalStructure(cifFilePath, optimalCrystalStructure);
		}


		catch (const System::ExceptionServices::IException& e)
		{
			std::cout << cifFilePath.generic_string() << std::endl;
			std::cout << e.toString() << std::endl;
		}

		catch (const std::exception& e)
		{
			std::cout << cifFilePath.generic_string() << std::endl;
			std::cout << e.what() << std::endl;
		}


		eraseFilePathsForParallel(cifFilePaths);
	}
}

// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private methods

std::queue<std::filesystem::path> ExtractCrystals::getCifFilePaths() const
{
	std::queue<std::filesystem::path> cifFilePaths;
	{
		for (const auto& cifFilePath : System::IO::Directory::enumerateFiles(_inputCrystalsDirectoryPath, "([\\-\\_[:alnum:]]+)[\\.]{1}cif", System::IO::Directory::SearchOptions::AllDirectories))
			cifFilePaths.push(cifFilePath);
	}

	return cifFilePaths;
}

void ExtractCrystals::eraseFilePathsInitially(std::queue<std::filesystem::path>& cifFilePaths) const
{
	for (size_type rep = 0; (!(cifFilePaths.empty()) && (rep < _threadRank)); ++rep)
		cifFilePaths.pop();
}

void ExtractCrystals::eraseFilePathsForParallel(std::queue<std::filesystem::path>& cifFilePaths) const
{
	for (size_type rep = 0; (!(cifFilePaths.empty()) && (rep < System::Parallel::ThreadingPolicy::maxThreading())); ++rep)
		cifFilePaths.pop();
}

void ExtractCrystals::outputOptimalCrystalStructure(std::filesystem::path inputCifFilePath, const OptimalCrystalStructure& optimalCrystalStructure) const
{
	OptimalCrystalStructure conventionalOptimalStructure = optimalCrystalStructure;
	conventionalOptimalStructure.conventionalizeStructure(_spaceGroupPrecision);
	std::string structureFingerprint = conventionalOptimalStructure.toDetailedStructuralFingerprint();

	std::filesystem::path spaceGroupDirectoryPath = getSpaceGroupDirectoryPath(conventionalOptimalStructure.spaceGroupNumber(), optimalCrystalStructure.toChemicalComposition().toReducedChemicalComposition());
	auto stateAndDirectory = getOutputDirectoryPath(structureFingerprint, spaceGroupDirectoryPath);


	if (stateAndDirectory.first)
	{
		System::IO::Directory::createDirectory(stateAndDirectory.second, System::IO::Directory::CreateOptions::none);

		outputFeasibleCrystallographicData(conventionalOptimalStructure, stateAndDirectory.second);
		{
			std::filesystem::path replicaCifFilePath = stateAndDirectory.second;
			replicaCifFilePath /= inputCifFilePath.filename();
			//System::IO::File::copy(inputCifFilePath, replicaCifFilePath, System::IO::File::CreateOptions::skip_existing);
		}


		std::filesystem::path fingerprintFilePath = stateAndDirectory.second;
		fingerprintFilePath /= s_fingerprintFilename;

		System::IO::FileStream fingerprintStreamWriter{ fingerprintFilePath, System::IO::FileStream::FileMode::createNew };
		fingerprintStreamWriter.write(structureFingerprint);
	}
}

// Private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private utility

std::filesystem::path ExtractCrystals::getSpaceGroupDirectoryPath(const SpaceGroupNumber spaceGroupNumber, const ChemicalComposition& composition) const
{
	std::filesystem::path spaceGroupDirectoryPath = _outputCrystalsDirectoryPath;
	{
		spaceGroupDirectoryPath /= composition.toChemicalSystem().toString();
		spaceGroupDirectoryPath /= composition.toString();
		spaceGroupDirectoryPath /= "SpaceGroup-";
		spaceGroupDirectoryPath += std::to_string(spaceGroupNumber);

		System::IO::Directory::createDirectories(spaceGroupDirectoryPath, System::IO::Directory::CreateOptions::skip_existing);
	}

	return spaceGroupDirectoryPath;
}

std::pair<bool, std::filesystem::path> ExtractCrystals::getOutputDirectoryPath(const std::string& outputFingerprint, const std::filesystem::path& spaceGroupPath) const
{
	size_type numDirectory = 1;
	{
		for (const auto& directoryPath : System::IO::Directory::enumerateDirectories(spaceGroupPath, System::IO::Directory::SearchOptions::TopDirectoryOnly))
		{
			std::vector<std::filesystem::path> fingerprintFilePaths = System::IO::Directory::enumerateFiles(directoryPath, s_fingerprintFilename);


			if (fingerprintFilePaths.empty())
				throw System::IO::FileNotFoundException{ typeid(*this), "getStructureIndex", "Could not find fingerprint file." };

			else if (1 < fingerprintFilePaths.size())
				throw System::IO::InvalidFileException{ typeid(*this), "getStructureIndex", "There are multiple fingerprint files." };

			else
			{
				System::IO::FileStream fingerprintStreamReader{ fingerprintFilePaths.back(), System::IO::FileStream::FileMode::openRead };


				if (outputFingerprint == fingerprintStreamReader.readAllTexts())
					return std::make_pair(false, directoryPath);
				else
					++numDirectory;
			}
		}
	}


	std::filesystem::path outputDirectoryPath = spaceGroupPath;
	outputDirectoryPath /= "Type-";
	outputDirectoryPath += std::to_string(numDirectory);

	return std::make_pair(true, outputDirectoryPath);
}

void ExtractCrystals::outputFeasibleCrystallographicData(const OptimalCrystalStructure& conventionalOptimalStructure, const std::filesystem::path& outputDirectoryPath) const
{
	std::filesystem::path conventionalCifFilePath = outputDirectoryPath;
	conventionalCifFilePath /= "conventionalStructure.cif";

	ChemToolkit::Crystallography::IO::CifStreamWriter conventionalCifStreamWriter{ conventionalCifFilePath, System::IO::FileStream::FileMode::create };
	conventionalCifStreamWriter.writeCrystallographicStructure(conventionalOptimalStructure, _spaceGroupPrecision);
}

// Private utility
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
