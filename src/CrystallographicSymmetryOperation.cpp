#include "CrystallographicSymmetryOperation.h"

#include <regex>

#include "StreamWriter.h"

#include "LengthCasting.h"

using namespace ChemToolkit::Crystallography::Symmetry;


// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors

double CrystallographicSymmetryOperation::s_defaultPrecision{ MathToolkit::UnitConversion::LengthCasting::cast<MathToolkit::UnitConversion::LengthCasting::Unit::Angstrom, MathToolkit::UnitConversion::LengthCasting::Unit::AtomicUnit>(0.1) };


CrystallographicSymmetryOperation::CrystallographicSymmetryOperation() noexcept
	: AffineMapping{ MathToolkit::LinearAlgebra::getIdentityMatrix<double, 3>() }
	, _precision{ s_defaultPrecision }
{
}

CrystallographicSymmetryOperation::CrystallographicSymmetryOperation(const NumericalMatrix& matrixPart) noexcept
	: AffineMapping{ matrixPart }
	, _precision{ s_defaultPrecision }
{
}

CrystallographicSymmetryOperation::CrystallographicSymmetryOperation(NumericalMatrix&& matrixPart) noexcept
	: AffineMapping{ std::move(matrixPart) }
	, _precision{ s_defaultPrecision }
{
}

CrystallographicSymmetryOperation::CrystallographicSymmetryOperation(const NumericalMatrix& matrixPart, const NumericalVector& columnPart) noexcept
	: AffineMapping{ matrixPart, columnPart }
	, _precision{ s_defaultPrecision }
{
}

CrystallographicSymmetryOperation::CrystallographicSymmetryOperation(NumericalMatrix&& matrixPart, NumericalVector&& columnPart) noexcept
	: AffineMapping{ std::move(matrixPart), std::move(columnPart) }
	, _precision{ s_defaultPrecision }
{
}

// Constructors
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Methods

std::string CrystallographicSymmetryOperation::toString() const
{
	std::string symmetryOperationString;
	symmetryOperationString += "\'";
	{
		for (unsigned short rowIndex = 0; rowIndex < 3; ++rowIndex)
		{
			std::string operationString;
			double xValue = matrixPart()(rowIndex, 0);
			double yValue = matrixPart()(rowIndex, 1);
			double zValue = matrixPart()(rowIndex, 2);
			double columnValue = columnPart()[rowIndex];

			if (addOperationTerm(operationString, xValue))
				operationString += "x";

			if (addOperationTerm(operationString, yValue))
				operationString += "y";

			if (addOperationTerm(operationString, zValue))
				operationString += "z";

			addOperationTerm(operationString, columnValue);

			symmetryOperationString += operationString;
			symmetryOperationString += ", ";
		}

		symmetryOperationString.pop_back();
		symmetryOperationString.pop_back();
		symmetryOperationString += "\'";
	}

	return symmetryOperationString;
}

bool CrystallographicSymmetryOperation::toCrystallographicSymmetryOperation(const std::string& text, CrystallographicSymmetryOperation& symmetryOperation)
{
	std::regex totalPat;
	std::smatch totalSm;
	{
		std::string totalPatString{ "[\\']{1}[\\s]*" };
		{
			std::string operationPatString{ "([xyz\\+\\-\\/\\.[:digit:]]+)" };

			totalPatString += operationPatString;
			totalPatString += "[\\,]{1}[\\s]*";
			totalPatString += operationPatString;
			totalPatString += "[\\,]{1}[\\s]*";
			totalPatString += operationPatString;
			totalPatString += "[\\s]*[\\']{1}";
		}

		totalPat = std::regex(totalPatString);
	}


	if (std::regex_search(text, totalSm, totalPat))
	{
		symmetryOperation = toCrystallographicSymmetryOperation(totalSm.str(1), totalSm.str(2), totalSm.str(3));
		return true;
	}

	else
		return false;
}

// Methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private methods

bool CrystallographicSymmetryOperation::addOperationTerm(std::string& operationString, const double value) const
{
	if (isZero(value))
		return false;

	else
	{
		if (isOne(value))
		{
			if (!(operationString.empty()))
				operationString += "+";
		}

		else if (isMinusOne(value))
			operationString += "-";
		else
		{
			System::IO::StreamWriter valueWriter;
			{
				if ((0.0 < value) && !(operationString.empty()))
				{
					valueWriter.write("+");
					valueWriter.write(value);
				}

				else
					valueWriter.write(value);
			}

			operationString += valueWriter.allTexts();
			operationString.pop_back();
		}

		return true;
	}
}

CrystallographicSymmetryOperation CrystallographicSymmetryOperation::toCrystallographicSymmetryOperation(const std::string& xOperation, const std::string& yOperation, const std::string& zOperation)
{
	NumericalMatrix matrixPart;
	NumericalVector columnPart;

	std::vector<std::string> operationStrings{ xOperation, yOperation, zOperation };

	for (unsigned short index = 0; index < 3; ++index)
	{
		std::string operationString{ operationStrings[index] };
		std::regex termPat("([xyz\\/\\.[:digit:]]+)");


		for (std::sregex_iterator iter(operationString.begin(), operationString.end(), termPat); iter != std::sregex_iterator{}; ++iter)
		{
			std::string termString = iter->str(1);
			double pmCoefficient{ 1.0 };
			{
				std::string prevText = iter->prefix().str();

				if (!(prevText.empty()))
				{
					if (prevText.back() == '-')
						pmCoefficient = (-1.0);
				}
			}

			if (termString.back() == 'x')
			{
				termString.pop_back();
				matrixPart(index, 0) = pmCoefficient * toTermValue(termString);
			}

			else if (termString.back() == 'y')
			{
				termString.pop_back();
				matrixPart(index, 1) = pmCoefficient * toTermValue(termString);
			}

			else if (termString.back() == 'z')
			{
				termString.pop_back();
				matrixPart(index, 2) = pmCoefficient * toTermValue(termString);
			}

			else
				columnPart[index] = pmCoefficient * toTermValue(termString);
		}
	}


	return CrystallographicSymmetryOperation{ matrixPart, columnPart };
}

// Private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
