#include "CifStreamReader.h"

#include <regex>

#include "ArgumentOutOfRangeException.h"
#include "IOException.h"
#include "File.h"
#include "StreamReader.h"

#include "LengthCasting.h"
#include "AngleCasting.h"

using namespace ChemToolkit::Crystallography::IO;


// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Constructors

CifStreamReader::CifStreamReader(const std::filesystem::path& cifFilePath)
	: FileStream{ cifFilePath, FileMode::openRead }
{
	if (!(isCorrectExtension(filePath())))
	{
		std::string errorMessage;
		{
			errorMessage += "The extension of \"";
			errorMessage += filePath().generic_string();
			errorMessage += "\", is not \"";
			errorMessage += correctExtension();
			errorMessage += "\".";
		}

		throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "constructor", errorMessage };
	}
}

// Constructors
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private methods

ChemToolkit::Crystallography::UnitCell CifStreamReader::readUnitCell(const System::IO::StreamReader& streamReader) const
{
	UnitCell::LatticeParameters latticeParameters;
	{
		using  namespace MathToolkit::UnitConversion;
		using Angstrom = LengthCasting::Unit::Angstrom;
		using AtomicUnit = LengthCasting::Unit::AtomicUnit;
		using Degree = AngleCasting::Unit::Degree;
		using Radian = AngleCasting::Unit::Radian;
		{
			double lengthA = 0.0;
			streamReader.readParameter("_cell_length_a", lengthA);
			latticeParameters.lengths.a = LengthCasting::cast<Angstrom, AtomicUnit>(lengthA);
		}
		{
			double lengthB = 0.0;
			streamReader.readParameter("_cell_length_b", lengthB);
			latticeParameters.lengths.b = LengthCasting::cast<Angstrom, AtomicUnit>(lengthB);
		}
		{
			double lengthC = 0.0;
			streamReader.readParameter("_cell_length_c", lengthC);
			latticeParameters.lengths.c = LengthCasting::cast<Angstrom, AtomicUnit>(lengthC);
		}
		{
			double angleA = 0.0;
			streamReader.readParameter("_cell_angle_alpha", angleA);
			latticeParameters.angles.alpha = AngleCasting::cast<Degree, Radian>(angleA);
		}
		{
			double angleB = 0.0;
			streamReader.readParameter("_cell_angle_beta", angleB);
			latticeParameters.angles.beta = AngleCasting::cast<Degree, Radian>(angleB);
		}
		{
			double angleC = 0.0;
			streamReader.readParameter("_cell_angle_gamma", angleC);
			latticeParameters.angles.gamma = AngleCasting::cast<Degree, Radian>(angleC);
		}
	}

	return UnitCell{ latticeParameters };
}

std::vector<ChemToolkit::Crystallography::AtomSite> CifStreamReader::readAtomSites(const std::string& inputText) const
{
	std::string atomSiteText = getLoopText(inputText, "_atom_site_fract_");
	std::vector<std::string> loopDataNames;
	{
		if (atomSiteText.empty())
			throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "readAtomSites", "Could not read atom sites." };
		else
			loopDataNames = readLoopDataNames(atomSiteText, "_atom_site_");
	}
	
	std::vector<AtomSite> atomSites;
	{
		std::stringstream atomSiteStream{ atomSiteText };

		std::regex pat("([[:alnum:]\\+\\-\\.\\(\\)]+)[\\s]*");
		std::regex totalPat;
		{
			std::string patText{ "[\\s]*" };;
			{
				for (const auto& loopDataName : loopDataNames)
					patText += std::string{ "([[:alnum:]\\+\\-\\.\\(\\)]+)[\\s]*" };
			}

			totalPat = std::regex{ patText };
		}


		for (std::string stringLine; std::getline(atomSiteStream, stringLine);)
		{
			std::smatch totalSm;

			if (std::regex_match(stringLine, totalSm, totalPat))
			{
				AtomSite atomSite;
				{
					NumericalVector fractionalCoordinate(3);
					auto loopDataNameIter = loopDataNames.begin();

					for (std::sregex_iterator iter(stringLine.begin(), stringLine.end(), pat); (iter != std::sregex_iterator{} && loopDataNameIter != loopDataNames.end()); ++iter, ++loopDataNameIter)
					{
						if ((*loopDataNameIter) == "_atom_site_label")
						{
							std::regex siteLabelPat("([[:alpha:]]+)([\\d]+)");
							std::smatch siteLabelSm;
							std::string siteLabel = iter->str(1);


							if (std::regex_match(siteLabel, siteLabelSm, siteLabelPat))
								atomSite.setSiteLabel(siteLabel);
							else
								throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "readAtomSites", "Could not read _atom_site_label." };
						}


						if ((*loopDataNameIter) == "_atom_site_type_symbol")
						{
							std::regex neutralSiteTypePat("([[:alpha:]]+)");
							std::regex chargedSiteTypePat("([[:alpha:]]+)([\\d\\+\\-]+)");
							std::smatch siteTypeSm;
							std::string siteTypeSymbol = iter->str(1);


							if (std::regex_match(siteTypeSymbol, siteTypeSm, neutralSiteTypePat))
							{
								atomSite.setAtomicNumber(AtomicNumber{ siteTypeSm.str(1) });
								atomSite.setFormalCharge(0);
							}

							else if (std::regex_match(siteTypeSymbol, siteTypeSm, chargedSiteTypePat))
							{
								atomSite.setAtomicNumber(AtomicNumber{ siteTypeSm.str(1) });
								atomSite.setFormalCharge(static_cast<AtomSite::charge_type>(toFormalCharge(siteTypeSm.str(2))));
							}

							else
								throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "readAtomSites", "Could not read _atom_site_label." };
						}


						if ((*loopDataNameIter) == "_atom_site_symmetry_multiplicity")
							atomSite.setSiteMultiplicity(static_cast<AtomSite::size_type>(System::IO::StreamReader::toIntegerValue(iter->str(1))));
						if ((*loopDataNameIter) == "_atom_site_Wyckoff_symbol")
							atomSite.setWyckoffSymbol(iter->str(1));
						if ((*loopDataNameIter) == "_atom_site_fract_x")
							fractionalCoordinate[0] = System::IO::StreamReader::toFractionalValue(iter->str(1));
						if ((*loopDataNameIter) == "_atom_site_fract_y")
							fractionalCoordinate[1] = System::IO::StreamReader::toFractionalValue(iter->str(1));
						if ((*loopDataNameIter) == "_atom_site_fract_z")
							fractionalCoordinate[2] = System::IO::StreamReader::toFractionalValue(iter->str(1));

						if ((*loopDataNameIter) == "_atom_site_occupancy")
						{
							double occupancy = System::IO::StreamReader::toFractionalValue(iter->str(1));
							atomSite.setSiteOccupancy(occupancy);
						}
					}

					atomSite.setFractionalCoordinate(fractionalCoordinate);
				}

				atomSites.push_back(std::move(atomSite));
			}
		}
	}

	return atomSites;
}

std::vector<ChemToolkit::Crystallography::IO::CifStreamReader::SymmetryOperation> CifStreamReader::readSymmetryOperations(const std::string& inputText) const
{
	std::string symmetryOperationsText;
	{
		symmetryOperationsText = getLoopText(inputText, "_space_group_symop_operation_xyz");
		{
			if (symmetryOperationsText.empty())
			{
				symmetryOperationsText = getLoopText(inputText, "_symmetry_equiv_pos_as_xyz");

				if (symmetryOperationsText.empty())
					throw System::IO::IOException{ typeid(*this), "readSpaceGroupInformation", "Could not read symmetry operations." };
			}
		}
	}

	std::vector<SymmetryOperation> symmetryOperations;
	{
		std::stringstream symmetryOperationStream{ symmetryOperationsText };

		for (std::string stringLine; std::getline(symmetryOperationStream, stringLine);)
		{
			SymmetryOperation symmetryOperation;

			if (SymmetryOperation::toCrystallographicSymmetryOperation(stringLine, symmetryOperation))
				symmetryOperations.push_back(std::move(symmetryOperation));
		}
	}

	return symmetryOperations;
}

// Public methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private methods

CifStreamReader::SpaceGroupNumber CifStreamReader::readSpaceGroupNumber(const System::IO::StreamReader& streamReader) const
{
	unsigned short number;

	if (streamReader.readParameter("_space_group_IT_number", number))
		return SpaceGroupNumber{ number };
	else
	{
		if (streamReader.readParameter("_symmetry_Int_Tables_number", number))
			return SpaceGroupNumber{ number };
		else
		{
			std::string message;
			{
				message += "Could not read the space group number in the cif file of \"";
				message += filePath().generic_string();
				message += "\".";
			}

			throw System::IO::IOException{ typeid(*this), "readSpaceGroupNumber", message };
		}
	}
}

// Private methods
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// Private utility

int CifStreamReader::toFormalCharge(const std::string& chargeTexts) const
{
	if (chargeTexts == "+")
		return 1;

	else if (chargeTexts == "-")
		return (-1);

	else
	{
		std::regex plusPat("([\\d]+)[\\+]{1}");
		std::regex minusPat("([\\d]+)[\\-]{1}");
		std::smatch sm;


		if (std::regex_match(chargeTexts, sm, plusPat))
			return std::stoi(sm.str(1));

		else if (std::regex_match(chargeTexts, sm, minusPat))
		{
			int formalCharge = std::stoi(sm.str(1));
			formalCharge *= (-1);
			return formalCharge;
		}

		else
			throw System::ExceptionServices::ArgumentOutOfRangeException{ typeid(*this), "toFormalCharge", "Charge text is invalid."};
	}
}

std::string CifStreamReader::getLoopText(const std::string& inputText, const std::string& dataSign) const
{
	auto fractPos = inputText.find(dataSign);
	{
		if (fractPos == std::string::npos)
			return std::string{};
	}

	auto initialLoopPos = inputText.rfind("loop_", fractPos);
	{
		if (initialLoopPos == std::string::npos)
			throw System::IO::IOException{ typeid(*this), "getloopText", "Could not find initial \"loop_\"." };
		else
			initialLoopPos += 6;
	}

	auto finalLoopPos = inputText.find("loop_", fractPos);
	{
		if (finalLoopPos == std::string::npos)
		{
			finalLoopPos = inputText.find("#End", fractPos);

			if (finalLoopPos == std::string::npos)
				finalLoopPos = inputText.size();
		}
	}


	if (initialLoopPos < finalLoopPos)
		return std::string{ inputText, initialLoopPos, (finalLoopPos - initialLoopPos) };
	else
		throw System::IO::IOException{ typeid(*this), "getloopText", "Could not find valid initial and/or final \"loop_\"." };
}

std::vector<std::string> CifStreamReader::readLoopDataNames(const std::string& inputText, const std::string& dataSign) const
{
	std::stringstream dataStream{ inputText };

	std::vector<std::string> dataNames;
	{
		for (std::string stringLine; std::getline(dataStream, stringLine);)
		{
			auto dataNamePos = stringLine.find(dataSign);

			if (dataNamePos == std::string::npos)
				break;

			else
			{
				std::regex pat("[\\s]*[\\_]{1}([\\_[:alpha:]]+)[\\s]*");
				std::smatch sm;

				if (std::regex_match(stringLine, sm, pat))
				{
					std::string dataName;
					{
						dataName += "_";
						dataName += sm.str(1);
					}

					dataNames.push_back(dataName);
				}

				else
					throw System::IO::IOException{ typeid(*this), "readAtomSites", "Invalid data name." };
			}
		}
	}

	return dataNames;
}

// Private utility
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
// **********************************************************************************************************************************************************************************************************************************************************************************************
